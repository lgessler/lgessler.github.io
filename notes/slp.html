<!doctype html>
<html lang="en">
<head>
<title>Speech and Language Processing 2ed, Chapter 3, FST's Speech and Language Processing 3ed, Chapter 4, Language Modeling with N-grams Speech and Language Processing 3ed draft, Chapter 9, Markov Chains Speech and Language Processing 3ed draft, Chapter 10, Formal Grammars of English Speech and Language Processing 3ed draft, Chapter 11, Syntactic Parsing Speech and Language Processing 3ed draft, Chapter 12, Probabilistic Parsing Speech and Language Processing 3ed draft, Chapter 13, Dependency Parsing</title>
<!-- 2018-08-25 Sat 01:42 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Luke Gessler">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style type="text/css">
/* org mode styles on top of twbs */

html {
    position: relative;
    min-height: 100%;
}

body {
    font-size: 18px;
    margin-bottom: 105px;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 101px;
    background-color: #f5f5f5;
}

footer > div {
    padding: 10px;
}

footer p {
    margin: 0 0 5px;
    text-align: center;
    font-size: 16px;
}

#table-of-contents {
    margin-top: 20px;
    margin-bottom: 20px;
}

blockquote p {
    font-size: 18px;
}

pre {
    font-size: 16px;
}

.footpara {
    display: inline-block;
}

figcaption {
  font-size: 16px;
  color: #666;
  font-style: italic;
  padding-bottom: 15px;
}

/* from twbs docs */

.bs-docs-sidebar.affix {
    position: static;
}
@media (min-width: 768px) {
    .bs-docs-sidebar {
        padding-left: 20px;
    }
}

/* All levels of nav */
.bs-docs-sidebar .nav > li > a {
    display: block;
    padding: 4px 20px;
    font-size: 14px;
    font-weight: 500;
    color: #999;
}
.bs-docs-sidebar .nav > li > a:hover,
.bs-docs-sidebar .nav > li > a:focus {
    padding-left: 19px;
    color: #A1283B;
    text-decoration: none;
    background-color: transparent;
    border-left: 1px solid #A1283B;
}
.bs-docs-sidebar .nav > .active > a,
.bs-docs-sidebar .nav > .active:hover > a,
.bs-docs-sidebar .nav > .active:focus > a {
    padding-left: 18px;
    font-weight: bold;
    color: #A1283B;
    background-color: transparent;
    border-left: 2px solid #A1283B;
}

/* Nav: second level (shown on .active) */
.bs-docs-sidebar .nav .nav {
    display: none; /* Hide by default, but at >768px, show it */
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 30px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav > li > a:focus {
    padding-left: 29px;
}
.bs-docs-sidebar .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav > .active:focus > a {
    padding-left: 28px;
    font-weight: 500;
}

/* Nav: third level (shown on .active) */
.bs-docs-sidebar .nav .nav .nav {
    padding-bottom: 10px;
}
.bs-docs-sidebar .nav .nav .nav > li > a {
    padding-top: 1px;
    padding-bottom: 1px;
    padding-left: 40px;
    font-size: 12px;
    font-weight: normal;
}
.bs-docs-sidebar .nav .nav .nav > li > a:hover,
.bs-docs-sidebar .nav .nav .nav > li > a:focus {
    padding-left: 39px;
}
.bs-docs-sidebar .nav .nav .nav > .active > a,
.bs-docs-sidebar .nav .nav .nav > .active:hover > a,
.bs-docs-sidebar .nav .nav .nav > .active:focus > a {
    padding-left: 38px;
    font-weight: 500;
}

/* Show and affix the side nav when space allows it */
@media (min-width: 992px) {
    .bs-docs-sidebar .nav > .active > ul {
        display: block;
    }
    /* Widen the fixed sidebar */
    .bs-docs-sidebar.affix,
    .bs-docs-sidebar.affix-bottom {
        width: 213px;
    }
    .bs-docs-sidebar.affix {
        position: fixed; /* Undo the static from mobile first approach */
        top: 20px;
    }
    .bs-docs-sidebar.affix-bottom {
        position: absolute; /* Undo the static from mobile first approach */
    }
    .bs-docs-sidebar.affix .bs-docs-sidenav,.bs-docs-sidebar.affix-bottom .bs-docs-sidenav {
        margin-top: 0;
        margin-bottom: 0
    }
}
@media (min-width: 1200px) {
    /* Widen the fixed sidebar again */
    .bs-docs-sidebar.affix-bottom,
    .bs-docs-sidebar.affix {
        width: 263px;
    }
}
</style>
<script type="text/javascript">
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><link rel='stylesheet' type='text/css' href='/css/styles.css'>
            <link href="https://fonts.googleapis.com/css?family=Roboto"
                  rel="stylesheet">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: "center",
  displayIndent: "2em",
  messageStyle: "none",
  "HTML-CSS": {
    scale: 100,
    styles: {
      ".MathJax_Display": {
        "font-size": "100%"
      }
    }
  },
  "SVG": {
    scale: 100,
    styles: {
      ".MathJax_SVG_Display": {
        "font-size": "100%",
        "margin-left": "-2.281em"
      }
    }
  }
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"></script>
</head>
<body>
<div id="preamble" class="">
<div class="container"><div class="row"><div class="col-md-9"><div style="font-size:11px;text-align:center;"><a style="color:gray;" href="/">Home</a> <a style="color:gray;" href="/posts/">Blog</a></div><div style="margin-top:0px;margin-bottom:-12px;color:#a0a0a0;">Luke Gessler</div></div></div></div>
</div>
<div id="content" class="container">
<div class="row"><div class="col-md-9"><h1 class="title">Speech and Language Processing 2ed, Chapter 3, FST's Speech and Language Processing 3ed, Chapter 4, Language Modeling with N-grams Speech and Language Processing 3ed draft, Chapter 9, Markov Chains Speech and Language Processing 3ed draft, Chapter 10, Formal Grammars of English Speech and Language Processing 3ed draft, Chapter 11, Syntactic Parsing Speech and Language Processing 3ed draft, Chapter 12, Probabilistic Parsing Speech and Language Processing 3ed draft, Chapter 13, Dependency Parsing</h1>
<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2.1</h3>
<div class="outline-text-3" id="text-">
</div><div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">a</h4>
<div class="outline-text-4" id="text-">
<p>
<code>/[a-zA-Z]*/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">b</h4>
<div class="outline-text-4" id="text-">
<p>
<code>/[a-z]*b/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">c</h4>
<div class="outline-text-4" id="text-">
<p>
<code>/(\w+)\s\1/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">d</h4>
<div class="outline-text-4" id="text-">
<p>
<code>/(b|bab)*/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">e</h4>
<div class="outline-text-4" id="text-">
<p>
Assuming greediness, we don't need to insert <code>\b</code>.
<code>/^[0-9]+.*\w+$/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">f</h4>
<div class="outline-text-4" id="text-">
<p>
<code>/.*\bgrotto\b.*\braven\b.*|.*\braven\b.*\bgrotto\b.*/</code>
</p>
</div>
</div>
<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">g</h4>
<div class="outline-text-4" id="text-">
<p>
<code>\w</code> and <code>\W</code> deal with punctuation, so we can simply write:
<code>/\W*(\w+)/</code>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2.8</h3>
<div class="outline-text-3" id="text-">
<p>
<code>/ab(aba?)*/</code>
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2.10</h3>
<div class="outline-text-3" id="text-">
<p>
The algorithm must transform the DFSA such that (1) all "holes" in the state-transition function are filled, and (2) the non-accepting states are made accepting states and vice versa. Python pseudocode:
</p>

<div class="org-src-container">

<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>:
    <span class="org-variable-name">alphabet</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>, ...<span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">0 - n-1 states, just assume q0 is the start state</span>
    <span class="org-variable-name">states</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'q0'</span>, <span class="org-string">'q1'</span>, <span class="org-string">'q2'</span>, <span class="org-string">'q3'</span>, ...<span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">some subset</span>
    <span class="org-variable-name">accepting_states</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'q_i'</span>, ...<span class="org-rainbow-delimiters-depth-1">]</span> 

    <span class="org-comment-delimiter"># </span><span class="org-comment">transition function modeled with a dict: top level is a state mapped to </span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">another dict, that dict is an alphabet character mapped to a state, </span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">representing state-transitions for the state on encountering a character</span>
    <span class="org-variable-name">trans_table</span> = <span class="org-rainbow-delimiters-depth-1">{</span><span class="org-string">'q0'</span>: <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">'a'</span>: <span class="org-string">'qi'</span>,
                          <span class="org-string">'b'</span>: <span class="org-string">'qj'</span>,
                          ...<span class="org-rainbow-delimiters-depth-2">}</span>,
                   ...<span class="org-rainbow-delimiters-depth-1">}</span>

    <span class="org-variable-name">states</span>, <span class="org-variable-name">accepting_states</span>, <span class="org-variable-name">trans_table</span> = \
            complement<span class="org-rainbow-delimiters-depth-1">(</span>alphabet, states, accepting_states, trans_table<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">modifies trans_table and states so that every state accepts every letter as input</span>
<span class="org-keyword">def</span> <span class="org-function-name">fill_trans_table</span><span class="org-rainbow-delimiters-depth-1">(</span>alphabet, states, trans_table<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-variable-name">dummy_state</span> = <span class="org-constant">None</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">We shouldn't modify a dict while we're looping over it, but this is pseudocode</span>
    <span class="org-keyword">for</span> state, transitions <span class="org-keyword">in</span> trans_table.items<span class="org-rainbow-delimiters-depth-1">()</span>:
        <span class="org-variable-name">missing_letters</span> = <span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> alphabet <span class="org-keyword">if</span> x <span class="org-keyword">not</span> <span class="org-keyword">in</span> transitions.keys<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">]</span>
        <span class="org-keyword">if</span> missing_letters: <span class="org-comment-delimiter">#</span><span class="org-comment">empty list is falsey</span>
            <span class="org-variable-name">dummy_state</span> = dummy_state <span class="org-keyword">or</span> <span class="org-string">'dummy'</span>
            <span class="org-keyword">for</span> letter <span class="org-keyword">in</span> missing_letters:
                trans_table<span class="org-rainbow-delimiters-depth-1">[</span>state<span class="org-rainbow-delimiters-depth-1">][</span>letter<span class="org-rainbow-delimiters-depth-1">]</span> = dummy_state

    <span class="org-comment-delimiter"># </span><span class="org-comment">only add the dummy state if we needed it</span>
    <span class="org-keyword">if</span> dummy_state:
        <span class="org-variable-name">trans_table</span><span class="org-rainbow-delimiters-depth-1">[</span>dummy_state<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">{</span>letter: dummy_state <span class="org-keyword">for</span> letter <span class="org-keyword">in</span> alphabet<span class="org-rainbow-delimiters-depth-1">}</span>
        states.append<span class="org-rainbow-delimiters-depth-1">(</span>dummy_state<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">def</span> <span class="org-function-name">complement</span><span class="org-rainbow-delimiters-depth-1">(</span>alphabet, states, accepting_states, trans_table<span class="org-rainbow-delimiters-depth-1">)</span>:
    fill_trans_table<span class="org-rainbow-delimiters-depth-1">(</span>alphabet, states, trans_table<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-variable-name">accepting_states</span> = <span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> alphabet <span class="org-keyword">if</span> x <span class="org-keyword">not</span> <span class="org-keyword">in</span> accepting_states<span class="org-rainbow-delimiters-depth-1">]</span>

    <span class="org-keyword">return</span> states, accepting_states, trans_table
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">2.11</h3>
<div class="outline-text-3" id="text-">
<p>
The above solution doesn't work for NFSA's because they are allowed to have more than one state-transition for a given state-input pair. One option, obviously, is to turn the NFSA into a DFSA and then run the complement algorithm on it.
</p>
<style>body { max-width: 700px; } img { width: 100%; }</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.4 FSTs</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Seven parts of an FST
<ul class="org-ul">
<li>\(Q = q_0, \ldots, q_{N-1}\), finite set of \(N\) states
</li>
<li>\(\Sigma\), finite set containing input strings
</li>
<li>\(\Delta\), finite set containg output strings
</li>
<li>\(q_0 \in Q\), start state
</li>
<li>\(F \subseteq Q\), the set of final states
</li>
<li>\(\delta(q,w)\), transition function between state and string pair and sets of new states. (There could be more than one.)
</li>
<li>\(\sigma(q,w)\), output function, like above but returns a set of possible strings
</li>
</ul>
</li>

<li>FSTs closed under union, inversion, composition, but not under difference, complementation, and intersection. 
</li>
<li>Sadly, not every FST can be determinized
</li>
<li>Subtype of FST's called <i>sequential transducers</i> 
<ul class="org-ul">
<li>deterministic on input &#x2013;&gt; \(\epsilon\) only allowed in \(\Delta\)
</li>
<li>generalization: <i>subsequentual transducer</i>, which generates additional output at final states
</li>
<li>Useful because they are linear on input
</li>
<li>Subsequential transducers can be determinized and minimized
</li>
<li>Sequential and subsequential transducers can't handle ambiguity
</li>
<li>Generalization of the subsequential transducer: <i>p-/subsequential transducer, which allows for /p</i> final output strings to be associated with each final state.
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.5 FSTs for Morphological Parsing</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Words treated as having lexical and surface levels
</li>
<li>Each has one character per arc/"segment on the tape"
</li>
<li>Two-level Morphology
<ul class="org-ul">
<li>\(\Sigma\) and \(\Delta\) combined into \(\Sigma^\prime \subseteq \Sigma \times \Delta\) where \(\Sigma^\prime\) consists of corresponding pairs called feasible pairs
</li>
<li>Application in morphological parsing: can take surface forms and produce lexical forms
</li>
<li>Actually, produces an intermediate form, which another FST uses to produce a lexical form
</li>
<li>Intermediate tape contains morpheme and word boundaries as well as what I might call the least marked allomorph of a morpheme (like {s} for English plural)
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.6 Orthographic Rules</h3>
<div class="outline-text-3" id="text-">
<pre class="example">
Lexical        f   o   x   +N  +Pl
Intermediate   f   o   x   ^   s   #
Surface        f   o   x   e   s
</pre>

<ul class="org-ul">
<li>To account for orthographic rules (like <i>foxes</i> instead of */foxs/), an intermediate tape needs to be introduced and another FST needs to be created for each orthographic rule to apply orthographic rules to the intermediate tape
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.7 Combining FST Lexicon and Rules</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>As shown above, Lexicon-FST maps between lexical and intermediate strings, and orthographic rules map between intermediate and surface strings
</li>
<li>Orthographic rules can be applied in series or parallel
</li>
<li>Advantage of FSTs: can flow either way depending on whether we want to generate or parse
</li>
<li>FST's are, in general, nondeterministic and to function efficiently must incorporate search algorithms because of the size of the search space
</li>
<li>To collapse the cascade between levels, can compose transducers in series (already seen in C2)
</li>
<li>Transducers in parallel can be combined by automaton intersection: takes Cartesian product of all states in all parallel machines.
</li>
<li>Fortunately, morphological parsing FST's are usually generated and users work at a higher level of abstraction
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.8 Lexicon-free FSTs: The Porter Stemmer</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Some applications only care about parsing a word's lemma (and not, e.g., detailed morphosyntactic information)
</li>
<li>We can do without a lexicon in this case
</li>
<li>Porter algorithm uses cascaded rewrite rules, e.g. ATIONAL &#x2013;&gt; ATE, ING &#x2013;&gt; \(\epsilon\)
</li>
<li>Not perfect: DOING &#x2013;&gt; DOE, EUROPEAN &#x2013;&gt; EUROPEAN (not EUROPE)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.9 Word and Sentence Tokenization</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>So far, turned words into morphemes
</li>
<li>Also need to turn text into words and sentences
</li>
<li>Modern tokenization techniques use ML, can get acceptable results using rule-based approaches
</li>
<li>Some languages like Chinese don't have reliable whitespace for tokenization
</li>
<li>Good baseline for Chinese: maximum matching/maxmatch, greedy algorithm that takes maximum length that can still be found in a dictionary
</li>
<li>maxmatch still struggles with unknown genres
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.10 Spelling correction</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Three increasingly broader problems to be solved:
<ul class="org-ul">
<li>Detecting errors that result in non-words
</li>
<li>Correcting errors that result in non-words without knowing about the word's context
</li>
<li>Using context to detect and correct spelling errors even if the input is a real English word
</li>
</ul>
</li>
<li>String edit distance useful 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.11 Minimum Edit Distance</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Minimal number of mutations (insertion, deletion, substitution) needed to turn one string into another
</li>
<li>Each operation is assigned a cost, Levenshtein distance when all costs are 1
</li>
<li>Can use DP for calculating edit  distance because it has optimal substructure
</li>
<li>MED also useful for finding word alignments, useful in many applications
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.1</h3>
<div class="outline-text-3" id="text-">

<figure>
<p><img src="./ltximg/fig36.png" class="img-responsive" alt="fig36.png">
</p>
</figure>

\begin{array}{ll}

q_0, q_{1a} & \text{proselyte} \\
q_0, q_{1a}, q_2 & \text{proselytize} \\
q_0, q_{1a}, q_2, q_3 & \text{proselytization} \\
q_0, q_{1a}, q_2, q_4 & \text{proselytizer} \\
q_0, q_{1a}, q_2, q_5 & \text{proselytizable} \\
q_0, q_{1a}, q_2, q_5, q_6 & \text{proselytizablity} \\
q_0, q_{1a}, q_2, q_5, q_6 & \text{* proselytizableness} \\
q_0, q_{1a}, q_2, q_5, q_9 & \text{? proselytizab[le]ly} \\

q_0, q_{1b} & \text{general (adj) } \\
q_0, q_{1b}, q_2 & \text{generalize} \\
q_0, q_{1b}, q_2, q_3 & \text{generalization} \\
q_0, q_{1b}, q_2, q_4 & \text{generalizer (not ungrammatical for me)} \\
q_0, q_{1b}, q_2, q_5 & \text{generalizable} \\
q_0, q_{1b}, q_2, q_5, q_{6a} & \text{generalizablility} \\
q_0, q_{1b}, q_2, q_5, q_{6b} & \text{? generalizableness} \\
q_0, q_{1b}, q_2, q_5, q_9 & \text{generalizably} \\

q_0, q_5 & \text{national} \\
q_0, q_5, q_{6a} & \text{nationality} \\
q_0, q_5, q_{6b} & \text{? nationalness} \\
q_0, q_5, q_{9} & \text{nationally} \\

q_0, q_5 & \text{ideal} \\
q_0, q_5, q_{6a} & \text{? ideality} \\
q_0, q_5, q_{6b} & \text{idealness} \\
q_0, q_5, q_{9} & \text{ideally} \\

q_0, q_5 & \text{formal} \\
q_0, q_5, q_{6a} & \text{formality} \\
q_0, q_5, q_{6b} & \text{formalness} \\
q_0, q_5, q_{9} & \text{formally} \\

q_0, q_7 & \text{affect} \\
q_0, q_7, q_8 & \text{affective} \\
q_0, q_7, q_8, q_6 & \text{affectiveness} \\
q_0, q_7, q_8, q_9 & \text{affectively} \\

q_0, q_{10} & \text{cause} \\
q_0, q_{10}, q_8 & \text{causative} \\
q_0, q_{10}, q_8, q_6 & \text{causativeness} \\

q_0, q_{11} & \text{mourn} \\
q_0, q_{11}, q_8 & \text{mournful} \\
q_0, q_{11}, q_8, q_6 & \text{mournfulness} \\
q_0, q_{11}, q_8, q_9 & \text{mournfully} \\

\end{array}
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.2</h3>
<div class="outline-text-3" id="text-">
<p>
This is the existing machine: 
</p>


<figure>
<p><img src="./ltximg/fig3-17.svg" class="img-responsive" alt="fig3-17.svg">
</p>
</figure>

<p>
This is an extended version that handles <i>sh</i> and <i>ch</i>. (Note that some exotic sequences like <i>zh</i> or <i>xh</i> are not necessarily handled correctly, but I think we can treat them as out of scope.)
</p>


<figure>
<p><img src="./ltximg/ex3_2.svg" class="img-responsive" alt="ex3_2.svg">
</p>
</figure>

<p>
State q<sub>6</sub> was introduced to model the state of having just seen a <i>c</i>. It can only be reached if a <i>c</i> is encountered at q<sub>0</sub>. If an <i>h, s, z</i>, or <i>x</i> is encountered, we go to q<sub>1</sub>, otherwise we go back to q<sub>0</sub>. Obviously we need the <i>h</i> because we want to handle <i>ch</i>, but we also need the <i>s, z,</i> and <i>x</i> to go to q<sub>1</sub> because if we sent them to q<sub>0</sub> we would not be able to handle a more exotic word like <code>stankiewicz^s#</code>. From here, it is just as in the other cases: if a morpheme boundary is encountered then we are able to make the transition to q<sub>2</sub>, etc.
</p>

<p>
We're not done yet. We need to add <i>h</i> to the q<sub>5</sub> &#x2013;&gt; q<sub>1</sub> edge as well as the q<sub>1</sub> &#x2013;&gt; q<sub>1</sub> loop. Note that this does not enforce that there was necessarily an <i>s</i> or a <i>c</i> before it, so a word like <i>haggadahs</i> would have an <i>e</i> inserted, yielding * <i>haggadahes</i>. But there are no native English words I can think of that end in an <i>h</i> that is not preceded by a <i>c</i> or <i>s</i>, so again, this seems like a fair simplification.
</p>

<p>
Finally, we also need to add <i>h</i> to the q<sub>2</sub> &#x2013;&gt; q<sub>1</sub> edge, as well as the q<sub>0</sub> &#x2013;&gt; q<sub>0</sub> loop. (We need this or else we'd reject any word that starts with an <i>h</i> if the interpretation of <i>other</i> is "any character not explicitly mentioned at least once somewhere in the FST".)
</p>

<p>
Test word list:
</p>

<ul class="org-ul">
<li><code>mash^s#</code>
</li>
<li><code>task^s#</code>
</li>
<li><code>moss^s#</code>
</li>
<li><code>box^s#</code>
</li>
<li><code>church^s#</code>
</li>
<li><code>ash^s#</code>
</li>
<li><code>hash^set^s#</code>
</li>
<li><code>aspic^s#</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.3</h3>
<div class="outline-text-3" id="text-">
<p>
Let's assume that a <i>k</i> is inserted when there is an environment like <code>...Vc_^{ing,ed}#</code>. I.e., there is a vowel followed by a <i>c</i>, followed by a morpheme boundary, followed by <i>ing</i> or <i>ed</i>, ending the word. This is the FST:
</p>


<figure>
<p><img src="./ltximg/ex3_3.jpg" class="img-responsive" alt="ex3_3.jpg">
</p>
</figure>

<p>
The first state is the default state. The state to its left models just having seen a vowel. The state to the right models just having seen a vowel <i>and</i> a <i>c</i>. From here, we must either (1) end the word, (2) end the word with <code>king#</code> or <code>ked#</code>, or return to one of the previous states.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.5</h3>
<div class="outline-text-3" id="text-">
<p>
To simplify the labels, let's use these abbreviations:
</p>

<p>
D = {a, e, h, i, o, u, w, y}
L1 = {b, f, p, v}
L2 = {c, g, j, k, q, s, x, z}
L3 = {d, t}
L4 = {l}
L5 = {m, n}
L6 = {r}
any = a-z
</p>

<p>
Let's also assume the input is terminated by #.
</p>

<p>
This is the FST:
</p>


<figure>
<p><img src="./ltximg/ex3_5.jpg" class="img-responsive" alt="ex3_5.jpg">
</p>
</figure>

<p>
Instead of carrying out the steps in sequence as the algorithm's description suggests, we need to carry them out all at once since the FST can only iterate over the input once. For instance, in order to account for step (c), we add null-emitting loops to states that have just accepted a letter, 
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.9</h3>
<div class="outline-text-3" id="text-">
<p>
Let's assume that if we encountered a <i>z</i>, <i>s</i>, or <i>x</i> at q<sub>5</sub> we would instead transition to q<sub>0</sub>. If this happened, q<sub>1</sub> would no longer correspond to the state of just having encountered one or more <i>z</i>, <i>s</i>, or <i>x</i> characters. Then if we encountered a string like <code>...s^ss^s#</code>, we would incorrectly fail to insert an <i>e</i>. 
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.10</h3>
<div class="outline-text-3" id="text-">
<p>
Setting all costs to 1, we find that <i>brief</i> and <i>divers</i> are equidistant from <i>drive</i>. If substituion cost were 2, however, <i>divers</i> would be closer.
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">
</colgroup>
<tbody>
<tr>
<td class="text-left">&#xa0;</td>
<td class="text-right">#</td>
<td class="text-right">d</td>
<td class="text-right">r</td>
<td class="text-right">i</td>
<td class="text-right">v</td>
<td class="text-right">e</td>
</tr>

<tr>
<td class="text-left">#</td>
<td class="text-right">0</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
<td class="text-right">5</td>
</tr>

<tr>
<td class="text-left">b</td>
<td class="text-right">1</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
<td class="text-right">5</td>
</tr>

<tr>
<td class="text-left">r</td>
<td class="text-right">2</td>
<td class="text-right">2</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">i</td>
<td class="text-right">3</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
</tr>

<tr>
<td class="text-left">e</td>
<td class="text-right">4</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
</tr>

<tr>
<td class="text-left">f</td>
<td class="text-right">5</td>
<td class="text-right">5</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
<td class="text-right">3</td>
<td class="text-right">3</td>
</tr>
</tbody>
</table>

<p>
Cost of 3:
</p>
<ul class="org-ul">
<li>substitute d
</li>
<li>insert v
</li>
<li>delete f
</li>
</ul>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">

<col  class="right">
</colgroup>
<tbody>
<tr>
<td class="text-left">&#xa0;</td>
<td class="text-right">#</td>
<td class="text-right">d</td>
<td class="text-right">r</td>
<td class="text-right">i</td>
<td class="text-right">v</td>
<td class="text-right">e</td>
</tr>

<tr>
<td class="text-left">#</td>
<td class="text-right">0</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
<td class="text-right">5</td>
</tr>

<tr>
<td class="text-left">d</td>
<td class="text-right">1</td>
<td class="text-right">0</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">i</td>
<td class="text-right">2</td>
<td class="text-right">1</td>
<td class="text-right">1</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
<td class="text-right">3</td>
</tr>

<tr>
<td class="text-left">v</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
<td class="text-right">2</td>
<td class="text-right">2</td>
<td class="text-right">1</td>
<td class="text-right">2</td>
</tr>

<tr>
<td class="text-left">e</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
<td class="text-right">3</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">r</td>
<td class="text-right">5</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
<td class="text-right">2</td>
</tr>

<tr>
<td class="text-left">s</td>
<td class="text-right">6</td>
<td class="text-right">5</td>
<td class="text-right">4</td>
<td class="text-right">4</td>
<td class="text-right">4</td>
<td class="text-right">3</td>
</tr>
</tbody>
</table>

<p>
Cost of 3:
</p>
<ul class="org-ul">
<li>insert r
</li>
<li>delete r
</li>
<li>delete s
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">3.11</h3>
<div class="outline-text-3" id="text-">
<div class="org-src-container">

<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">dist</span><span class="org-rainbow-delimiters-depth-1">(</span>source, target<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-variable-name">source</span> = <span class="org-string">" "</span> + source
    <span class="org-variable-name">target</span> = <span class="org-string">" "</span> + target
    <span class="org-variable-name">ls</span> = <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>source<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-variable-name">lt</span> = <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>target<span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-variable-name">m</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-3">(</span>lt<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-2">(</span>ls<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>ls<span class="org-rainbow-delimiters-depth-1">)</span>:
        m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span> = i
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>lt<span class="org-rainbow-delimiters-depth-1">)</span>:
        m<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span> = j

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>,ls<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>,lt<span class="org-rainbow-delimiters-depth-1">)</span>:
            <span class="org-variable-name">insc</span> = m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span>
            <span class="org-variable-name">delc</span> = m<span class="org-rainbow-delimiters-depth-1">[</span>i-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span>
            <span class="org-variable-name">subc</span> = m<span class="org-rainbow-delimiters-depth-1">[</span>i-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span>
            <span class="org-variable-name">cost</span> = <span class="org-builtin">min</span><span class="org-rainbow-delimiters-depth-1">(</span>insc, delc, subc<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span> <span class="org-keyword">if</span> source<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span> != target<span class="org-rainbow-delimiters-depth-2">[</span>j<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">else</span> <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">)</span>
            m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span> = cost
    <span class="org-keyword">return</span> m<span class="org-rainbow-delimiters-depth-1">[</span>ls-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>lt-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span>
dist<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"divers"</span>, <span class="org-string">"drive"</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
<style>body { max-width: 700px; } li { padding-bottom: 20px; }</style>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.1 N-grams</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>We often want to calculate \(P(w_1, \ldots, w_n)\) or \(P(w_n | w_1, \ldots, w_{n-1})\)
</li>
<li>One way for the latter: calculate \[\frac{C(w_1, \ldots, w_n)}{C(w_1, \ldots, w_{n-1})}\] in some corpus. But this is tiny/zero for all but the smallest values of \(n\)
</li>
<li>Another way: try the chain rule \[P(w_1, \ldots, w_n) = \prod_{k=1}^n P(w_k | w_1, \ldots, w_{k-1})\] But what's \(P(w_k|w_1 \ldots w_{k-1})\)? No obvious answer
</li>
<li>One way to simplify it: make Markov assumption that the probability of a word only depends on the word before it: \( P(w_n|w_1 \ldots w_{n-1}) \approx P(w_n | w_{n-1}) \)
</li>
<li>Markov assumption uses bigrams, generalizable to n-grams:  \[ P(w_n|w_1 \ldots w_{n-1}) \approx P(w_n | w_{n-N+1}, \ldots, w_{n-1}) \]
</li>
<li>How could you get \( P(w_n|w_{n-1}) \)? Maximum likelihood estimation equates this to \[ \frac{C(w_{n-1}, w_n)}{\sum_{v \in W} C(w_{n-1}v)} = \frac{C(w_{n-1}, w_n)}{C(w_{n-1})} \]
</li>
<li>When \( N > 1 \), sentences in the corpus need to be padded with special sentence boundary symbols e.g. <code>&lt;s&gt; &lt;s&gt; I am sam &lt;/s&gt; &lt;/s&gt;</code> for a trigram.
</li>
<li>Bigrams and trigrams are common, 4-grams and 5-grams uncommon because of sparsity
</li>
<li>Log probabilities used to avoid underflow
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.2 Evaluating language models</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Two kinds: intrinsic evaluation measures model quality independent of any "application", extrinsic evaluation measures based on some kind of application 
</li>
<li>Intrinsic evaluation requires a test set separate from the training set
</li>
<li>One kind of intrinsic evaluation: the likelihood of the test set
</li>
<li>Perplexity: inverse likelihood of the test set, normalized by word number. Suppose a bigram model and a test set \( W = w_1, \ldots, w_N \) where \(N\) is the size of the test set (and not necessarily the size of the vocabulary):
</li>
</ul>

<p>
\[ PP(W) = \sqrt[N]{\prod_{i=1}^N \frac{1}{P(w_i|w_{i-1})}} \]
</p>

<ul class="org-ul">
<li>Perplexity can also be thought of as weighted average branching factor 
</li>
<li>Perplexity best used as a quick check, for real quality checking you need an extrinsic test
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.3 Generalization and zeros</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Different domains have domain-specific language
</li>
<li>Different domain-specific languages may not overlap very much (Shakespeare vs. newspaper corpora probably have little) 
</li>
<li>Need to make sure your training set matches your target set's <i>genre</i>
</li>
<li>Increasing \(N\) improves performance, but makes the probability space explode
</li>
<li>N-grams that did not appear in our training set but are actually valid strings become more common
</li>
<li>One way to combat the sparsity: close the vocabulary, treat anything that isn't in the vocabulary as a single n-gram type
</li>
<li>Caution: perplexity can be hacked if vocabulary becomes small. (Most n-grams are assigned to the unknown type.)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.4 Smoothing</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>We can do better than assigning every previously-unseen n-gram to an unknown type
</li>
<li>Laplace smoothing: 
<ul class="org-ul">
<li>add one to all counts, normalize. (N is the number of word tokens, V is the number of word types) \[ P_\text{Laplace}(w_i) = \frac{c_i + 1}{N + V} \]
</li>
<li>Interesting to find the adjusted count: \[c_i^* = (c_i + 1)\frac{N}{N + V}\]
</li>
<li>Redistributes too much mass to zeros
</li>
</ul>
</li>
<li>Add-k smoothing: generalization of Laplace smoothing for \(k\) instead of 1.
</li>
<li>Backoff and interpolation
<ul class="org-ul">
<li>Simple backoff: if \(N\)-gram is zero, check if \(N-1\)-gram isn't zero, etc.
</li>
<li>Interpolation: linear mix of 1-Ngrams. For trigram: \[ \hat{P}(w_n|w_{n-1},w_{n-2}) = \lambda_1 P(w_n|w_{n-2},w_{n-1}) + \lambda_2 P(w_n|w_{n-1}) + \lambda_3 P(w_n) \\\sum_i \lambda_i = 1 \]
</li>
<li>\(\lambda\) values trained on a held-out corpus, another, separate training corpus
</li>
</ul>
</li>
<li>Katz backoff
<ul class="org-ul">
<li>for backoff to preserve correct probability distribution, need to take mass away from higher n-gram distributions
</li>
<li>mass is taken away from the higher order n-grams, given via a function \(\alpha\) to lower-order n-grams during the recursive backoff step
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.5 Kneser-Ney smoothing</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Absolute discounting: fixed amount is subtracted from all counts, interpolate with a lower-order model \[P(w_i|w_{i-1}) = \frac{\text{max}(C(w_{i-1}, w_i) - d, 0)}{C(w_{i-1})} + \lambda(w_{i-1})P(w_i) \] (note that the \(\lambda\) term must redistribute the mass to preserve the integrity of the distribution)
</li>
<li>K-N based on absolute discounting, but uses a specialized unigram model
</li>
<li>Intuition: some unigrams are very common but only appear in a few fixed phrases, like Kong
</li>
<li>To find \(P_\text{continuation}(w)\), find all word types that precede \(w\) and normalize by the total number of word bigram types: \[ P_\text{continuation}(w) = \frac{|\{v:C(vw)>0\}|}{|\{(a,b):C(a,b) > 0\}|} \]
</li>
<li>Frequent word with few phrases it appears in like Kong will have low continuation
</li>
<li>Final K-N formula is a modified version of absolute discounting: \[P(w_i|w_{i-1}) = \frac{\text{max}(C(w_{i-1}, w_i) - d, 0)}{C(w_{i-1})} + \lambda(w_{i-1})P_\text{continuation}(w_i) \] 
</li>
<li>The \(\lambda\) term normalizes the mass
</li>
<li>K-N uses a recursive formulation with a \(\lambda\) term adjusting each recursive call
</li>
<li>Normal count used for the highest order, continuation count used for lower orders
</li>
<li>Modified Kneser-Ney uses different discount for each value of \(n\)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">The web and stupid backoff</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Various tricks and approximations make web scale LM's feasible, incl. Bloom filters
</li>
<li>For very large LM's, K-N is possible but stupid backoff shown to be sufficient
</li>
<li>Stupid backoff 
<ul class="org-ul">
<li>gives up modeling a true probability distribution
</li>
<li>No discounting higher-order probabilities
</li>
<li>If backoff needed, back off, but penalize it with some constant \(\lambda \in [0,1]\)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.1</h3>
<div class="outline-text-3" id="text-">
<p>
Formula for trigram probability:
</p>

<p>
\( P(w_n|w_{n-2}w_{n-1}) = \frac{C(w_{n-2}w_{n-1}w_n)}{C(w_{n-2}w_{n-1})} \)
</p>

<p>
Bigram counts:
</p>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">seq</th>
<th scope="col" class="text-right">freq</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">&lt;s&gt; &lt;s&gt;</td>
<td class="text-right">3</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; I</td>
<td class="text-right">2</td>
</tr>

<tr>
<td class="text-left">I am</td>
<td class="text-right">2</td>
</tr>

<tr>
<td class="text-left">am Sam</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">Sam &lt;/s&gt;</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">&lt;/s&gt; &lt;/s&gt;</td>
<td class="text-right">3</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; Sam</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">Sam I</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">am &lt;/s&gt;</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">I do</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">do not</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">not like</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">like green</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">green eggs</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">eggs and</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">and ham</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">ham &lt;/s&gt;</td>
<td class="text-right">1</td>
</tr>
</tbody>
</table>

<p>
Trigram probabilities: 
</p>
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">

<col  class="left">

<col  class="right">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">Trigram</th>
<th scope="col" class="text-right">Count</th>
<th scope="col" class="text-left">Trigram probability</th>
<th scope="col" class="text-right">Val</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">&lt;s&gt; &lt;s&gt; I</td>
<td class="text-right">2</td>
<td class="text-left">P(I &vert; &lt;s&gt; &lt;s&gt;)</td>
<td class="text-right">2/3</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; I am</td>
<td class="text-right">1</td>
<td class="text-left">P(am &vert; &lt;s&gt; I)</td>
<td class="text-right">1/2</td>
</tr>

<tr>
<td class="text-left">I am Sam</td>
<td class="text-right">1</td>
<td class="text-left">P(Sam &vert; I am)</td>
<td class="text-right">1/2</td>
</tr>

<tr>
<td class="text-left">am Sam &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; am Sam)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">Sam &lt;/s&gt; &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; Sam &lt;/s&gt;)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; &lt;s&gt; Sam</td>
<td class="text-right">1</td>
<td class="text-left">P(Sam &vert; &lt;s&gt; &lt;s&gt;)</td>
<td class="text-right">1/3</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; Sam I</td>
<td class="text-right">1</td>
<td class="text-left">P(I &vert; &lt;s&gt; Sam)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">Sam I am</td>
<td class="text-right">1</td>
<td class="text-left">P(am &vert; Sam I)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">I am &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; I am)</td>
<td class="text-right">1/2</td>
</tr>

<tr>
<td class="text-left">am &lt;/s&gt; &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; am &lt;/s&gt;)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; I do</td>
<td class="text-right">1</td>
<td class="text-left">P(do &vert; &lt;s&gt; I)</td>
<td class="text-right">1/2</td>
</tr>

<tr>
<td class="text-left">I do not</td>
<td class="text-right">1</td>
<td class="text-left">P(not &vert; I do)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">do not like</td>
<td class="text-right">1</td>
<td class="text-left">P(like &vert; do not)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">not like green</td>
<td class="text-right">1</td>
<td class="text-left">P(green &vert; not like)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">like green eggs</td>
<td class="text-right">1</td>
<td class="text-left">P(eggs &vert; like green)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">green eggs and</td>
<td class="text-right">1</td>
<td class="text-left">P(and &vert; green eggs)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">eggs and ham</td>
<td class="text-right">1</td>
<td class="text-left">P(ham &vert; eggs and)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">and ham &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; and ham)</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">ham &lt;/s&gt; &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">P(&lt;/s&gt; &vert; ham &lt;/s&gt;)</td>
<td class="text-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.2</h3>
<div class="outline-text-3" id="text-">
<p>
According to fig. 4.2, 
</p>

<p>
P(i want chinese food) 
</p>

<p>
= P(&lt;s&gt; i want chinese food &lt;/s&gt;) 
</p>

<p>
= P(i | &lt;s&gt;) P(want | i) P(chinese | want) P(food | chinese) P(&lt;/s&gt; | food)
</p>

<p>
= 0.25 * 0.33 * 0.0065 * 0.52 * 0.68
</p>

<p>
= 1.9e-4
</p>

<p>
According to fig 4.6 (note: first and last probabilities are reused from before since they're not given again in 4.6):
</p>

<p>
= P(i | &lt;s&gt;) P(want | i) P(chinese | want) P(food | chinese) P(&lt;/s&gt; | food)
</p>

<p>
= 0.25 * 0.21 * 0.0029 * 0.052 * 0.68
</p>

<p>
= 5.4e-6
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.3</h3>
<div class="outline-text-3" id="text-">
<p>
Unsmoothed is higher. Intuitively, additive smoothing takes probability mass proportionate to the amount of mass a certain outcome has, making less-seen outcomes more likely and more-seen outcomes less likely. We can see that P(food | chinese), which used to have <i>p = 0.52</i>, was discounted by a factor of ten! On the other hand, P(chinese | want), which had the lower probability <i>p = 0.0065</i>, had <i>p = 0.0029</i> after smoothing. 
</p>

<p>
In the sense that the unsmoothed model assigns it a higher probability than the smoothed model, the sentence "I want chinese food" is a "likely" sentence. If we had encountered an "unlikely" sentence such as "I want roasted zucchini skin and", we would have expected the opposite: the unsmoothed model would have assigned it a lower probability.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.4</h3>
<div class="outline-text-3" id="text-">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">

<col  class="left">

<col  class="right">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">bigram</th>
<th scope="col" class="text-right">raw count</th>
<th scope="col" class="text-left">unigram</th>
<th scope="col" class="text-right">raw count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">&lt;s&gt; I</td>
<td class="text-right">3</td>
<td class="text-left">&lt;s&gt;</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">I am</td>
<td class="text-right">3</td>
<td class="text-left">&lt;/s&gt;</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">am Sam</td>
<td class="text-right">2</td>
<td class="text-left">I</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">Sam &lt;/s&gt;</td>
<td class="text-right">2</td>
<td class="text-left">am</td>
<td class="text-right">3</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; Sam</td>
<td class="text-right">1</td>
<td class="text-left">Sam</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">Sam I</td>
<td class="text-right">1</td>
<td class="text-left">do</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">am &lt;/s&gt;</td>
<td class="text-right">1</td>
<td class="text-left">not</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">I do</td>
<td class="text-right">1</td>
<td class="text-left">like</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">do not</td>
<td class="text-right">1</td>
<td class="text-left">green</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">not like</td>
<td class="text-right">1</td>
<td class="text-left">eggs</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">like green</td>
<td class="text-right">1</td>
<td class="text-left">and</td>
<td class="text-right">1</td>
</tr>

<tr>
<td class="text-left">green eggs</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>

<tr>
<td class="text-left">eggs and</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>

<tr>
<td class="text-left">and Sam</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
By formula 4.21, P(Sam | am) = \(\frac{C(\texttt{am sam}) + 1}{C(\texttt{am}) + V}\) = \( \frac{2 + 1}{3 + 11} \) = \( \frac{3}{14} \)
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.5</h3>
<div class="outline-text-3" id="text-">
<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="right">

<col  class="left">

<col  class="right">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">bigram</th>
<th scope="col" class="text-right">count</th>
<th scope="col" class="text-left">unigram</th>
<th scope="col" class="text-right">count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">&lt;s&gt; a</td>
<td class="text-right">2</td>
<td class="text-left">&lt;s&gt;</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">&lt;s&gt; b</td>
<td class="text-right">2</td>
<td class="text-left">a</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">a a</td>
<td class="text-right">1</td>
<td class="text-left">b</td>
<td class="text-right">4</td>
</tr>

<tr>
<td class="text-left">a b</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>

<tr>
<td class="text-left">b b</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>

<tr>
<td class="text-left">b a</td>
<td class="text-right">1</td>
<td class="text-left">&#xa0;</td>
<td class="text-right">&#xa0;</td>
</tr>
</tbody>
</table>

<table class="table table-striped table-bordered table-hover table-condensed">


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="text-left">probability</th>
<th scope="col" class="text-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="text-left">P(a &vert; &lt;s&gt;)</td>
<td class="text-left">1/2</td>
</tr>

<tr>
<td class="text-left">P(b &vert; &lt;s&gt;)</td>
<td class="text-left">1/2</td>
</tr>

<tr>
<td class="text-left">P(a &vert; a)</td>
<td class="text-left">1/4</td>
</tr>

<tr>
<td class="text-left">P(b &vert; a)</td>
<td class="text-left">1/4</td>
</tr>

<tr>
<td class="text-left">P(b &vert; b)</td>
<td class="text-left">1/4</td>
</tr>

<tr>
<td class="text-left">P(a &vert; b)</td>
<td class="text-left">1/4</td>
</tr>
</tbody>
</table>


<p>
P(a a) = P(a|&lt;s&gt;) P(a|a) 
</p>

<p>
= \( \frac{C(\lt\text{s}\gt \text{a})}{C(\lt\text{s}\gt)} \times \frac{\text{C(a a)}}{\text{C(a)}} \) 
</p>

<p>
= 1/2 * 1/4 = 1/8
</p>

<p>
P(a b) = P(a | &lt;s&gt;) * P(b | a) = 1/2 * 1/4 = 1/8
</p>

<p>
P(b a) = P(b | &lt;s&gt;) * P(a | b) = 1/2 * 1/4 = 1/8
</p>

<p>
P(b b) = P(b | &lt;s&gt;) * P(b | b) = 1/2 * 1/4 = 1/8
</p>

<p>
Since we know P(a | &lt;s&gt;) = P(b | &lt;s&gt;) and P(a | b) = P(a | a) = P(b | a) = P(b | b), we know the sum probability of all three-letter sentences is \(\sum_1^{2^3} \frac{1}{16} = \frac{1}{2} \)
</p>

<p>
Hmm&#x2026; these both add up to 1/2 instead of 1 like the book says they should, but this is still far enough to demonstrate what the book wanted us to: that the sum of probabilities across all sentences does not add up to 1.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.6</h3>
<div class="outline-text-3" id="text-">
\begin{array}{lll}
P(w_3|w_1,w_2) & = \frac{C(w_1, w_2, w_3) + 1}{C(w_1, w_2) + V^2}
\end{array}

<p>
Note that we have to square <i>V</i> because that is the total number of bigrams.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">4.7</h3>
<div class="outline-text-3" id="text-">
<p>
With this approach:
</p>

\begin{array}{lll}
P(w_2|w_1) &=& \lambda_1P(w_2|w_1) + \lambda_2P(w_1) \\

&=& \lambda_1 \frac{C(w_1w_2)}{C(w_1)} + \lambda_2 \frac{C(w_1)}{\sum_i C(w_i)}
\end{array}

<p>
For our specific words,
</p>


\begin{array}{lll}
P(\text{Sam}|\text{am}) &=& \lambda_1 \frac{C(\text{am Sam})}{C(\text{am})} + \lambda_2 \frac{C(\text{am})}{\sum_i C(w_i)} \\

&=& \frac{1}{2} \frac{2}{3} + \frac{1}{2} \frac{3}{25} \\

&=& \frac{118}{300}
\end{array}
<style>
body { 
    max-width: 800px; 
    margin: 0 auto 0 auto;
} 
img { width: 100%; }
</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">9.1 Markov Chains</h3>
<div class="outline-text-3" id="text-">
<p>
Formal components: states, transition probability matrix, start and end state:
</p>

<ul class="org-ul">
<li>\( Q = q_1q_2\ldots q_N \)
</li>
<li>\( A = a_{01}a_{02}\ldots a_{n1}\ldots a_{nn} \)
</li>
<li>\( q_0, q_F \)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">9.2 Hidden Markov Models</h3>
<div class="outline-text-3" id="text-">
<p>
Parts:
</p>

<ul class="org-ul">
<li>\( Q = q_1q_2\ldots q_N \)
<ul class="org-ul">
<li>A set of \(N\) states
</li>
</ul>
</li>
<li>\( A = a_{11}a_{12}\ldots a_{n1}\ldots a_{nn} \)
<ul class="org-ul">
<li>A transition probability matrix
</li>
</ul>
</li>
<li>\( O = o_1o_2\ldots o_T \)
<ul class="org-ul">
<li>A sequence of observations, each one drawn from \( V = v_1,v_2, \ldots, v_V \)
</li>
</ul>
</li>
<li>\(B = b_i(o_t)\)
<ul class="org-ul">
<li>A sequence of observation likelihoods/emission probabilities, i.e., \(p(o_t)\) at state \(i\)
</li>
</ul>
</li>
<li>\(q_0,q_F\)
</li>
</ul>

<p>
Three fundamental problems:
</p>

<ul class="org-ul">
<li>Likelihood: given an HMM \(\lambda = (A,B)\) and an observation sequence \(O\), determine \(P(O|\lambda)\)
</li>
<li>Decoding: given an observation sqeuence \(O\) and an HMM \(\lambda = (A,B)\), discover the best hidden state sequence \(Q\)
</li>
<li>Learning: Given an observation sequence \(O\) and the set of states in the HMM, learn the HMM parameters \(A\) and \(B\)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">9.3 Computing likelihood, forward algorithm</h3>
<div class="outline-text-3" id="text-">
<p>
Naive algorithm for \(P(O|\lambda)\): 
</p>

<p>
\[ \sum_Q P(O|Q)P(Q) \text{ where } P(O|Q)P(Q) = \prod_{i=1}^TP(o_i|q_i) \prod_{i=1}^TP(q_i|q_{i-1}) \] 
</p>

<p>
This takes exponential time to compute, not practical
</p>

<p>
Forward algorithm takes \(O(N^2T)\) time:
</p>

<ul class="org-ul">
<li>Construct forward trellis
</li>
<li>Each cell in trellis represents probability of being in a certain state after \(j\) observations: \(\alpha_t(j) = P(o_1, \ldots, o_t,q_t=j|\lambda)\)
</li>
<li>To compute \(\alpha_t(j)\), sum over every possible path: 
</li>
</ul>

<p>
\[ \alpha_t(j) = \sum_{i=1}^N a_{t-1}(i) a_{ij} b_j(o_t) \]
</p>

<ul class="org-ul">
<li>\(\alpha_{t-1}(i)\) is a previous cell's value, \(a_{ij}\) is the transition probability, and \(b_j(o_t)\) is the probability of observing \(o_t\) at state \(j\)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">9.4 Decoding, Viterbi algorithm</h3>
<div class="outline-text-3" id="text-">
<p>
Want to find most likely \(Q=q_1q_2q_3\ldots q_T\) given \(\lambda\) and \(O=o_1,o_2,\ldots,o_T\). 
</p>

<p>
Viterbi is also a DP algorithm that uses a trellis. Each cell expresses the probability:
</p>

<p>
\[ v_t(j) = \max_{q_0,q_1,\ldots,q_{t-1}}P(q_0,q_1,\ldots q_{t-1},o_1,o_2,\ldots o_t, q_t=j|\lambda) \]
</p>

<p>
Each cell is computed as:
</p>

<p>
\[ v_t(j) = \max_{i=1}^N v_{t-1}(i)a_{ij}b_j(o_t) \]
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">9.5 Training, forward-backward algorithm</h3>
<div class="outline-text-3" id="text-">
<p>
Given a sequence of observations \(O\) and a set of possible states \(Q\), need to find the HMM parameters \(A\) (transition probabilities) and \(B\) (emission probabilities).
</p>

<p>
If we were training a Markov chain, we could estimate each transition probability by expectation maximization:
</p>

<p>
\[ a_{ij} = \frac{C(i\rightarrow j)}{\sum_{q \in Q} C(i\rightarrow q)} \]
</p>

<p>
But in HMM training, we don't know which states we were in. Baum-Welch algorithm applies two intuitions:
</p>

<ol class="org-ol">
<li>Iteratively estimate counts
</li>
<li>Compute forward probability for an observation, but then also divide that probability mass among all paths that contributed to it
</li>
</ol>

<p>
Background: backward probability \(\beta\), the probability of seeing the observations from the time \(t + 1\) to the end, given that we are in state \(i\) at time \(t\), computed inductively as with the forward algorithm:
</p>

<p>
\[ \beta_t(i) = P(o_{t+1},o_{t+2},\ldots,o_T|q_t = i,\lambda) \]
</p>

<p>
Let \(\xi_t\) be the probability of being in state \(i\) at time \(t\) and state \(j\) at time \(t+1\):
</p>

<p>
\[ \xi_t(i,j) = P(q_t=i,q_{t+1}=j|O,\lambda) \]
</p>

<p>
To compute \(\xi_t\), compute something similar that includes probability of the observation:
</p>

<p>
\[ \text{not-quite-}\xi_t(i,j) = P(q_t=i,q_{t+1}=j,O|\lambda)  \]
</p>

<p>
This can be computed using forward and backward probabilities:
</p>

<p>
\[ \text{not-quite-}\xi_t(i,j) = \alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j) \]
</p>

<p>
Now, to arrive at \(\xi\), divide by \(P(O|\lambda)\), since
</p>

<p>
\[ P(X|Y,Z) = \frac{P(X,Y|Z)}{P(Y|Z)} \]
</p>

<p>
Can be computed a number of different ways:
</p>

<p>
\[ P(O|\lambda) = \alpha_T(q_F) = \beta_T(q_0) = \sum_{j=1}^N \alpha_t(j)\beta_t(j) \]
</p>

<p>
Putting it all together, \(\xi_t\):
</p>

<p>
\[ \xi_t(i,j) = \frac{\alpha_t(i)a_{ij}b_j(o_{t+1})\beta_{t+1}(j)}{\alpha_T(q_F)} \]
</p>

<p>
We need to estimate \(a_{ij}\):
</p>

<p>
\[ \hat{a}_{ij} = \frac{\sum_{t=1}^{T-1}\xi_t(i,j)}{\sum_{t=1}^{T-1}\sum_{k=1}^N\xi_t(i,k)} \]
</p>

<p>
Also need to estimate \(b_j(v_k)\):
</p>

<p>
\[ \hat{b}_j(v_k) = \frac{\text{expected number of times in state }j\text{ and observing symbol }v_k}{\text{expected number of times in state }j} \]
</p>

<p>
For this, need probability of being in state \(j\) at time \(t\), \(\gamma_t(j)\):
</p>

<p>
\[ \gamma_t(j) = P(q_t=j|O,\lambda) \]
</p>

<p>
Compute by using that one weird trick:
</p>

<p>
\[ \gamma_t(j) = \frac{P(q_t=j,O|\lambda)}{P(O|\lambda)} = \frac{\alpha_t(j)\beta_t(j)|\lambda)}{P(O|\lambda)} \]
</p>

<p>
Now we can write:
</p>

<p>
\[ \hat{b}_j(v_k) = \frac{\sum_{t=1\text{s.t.}o_t=v_k}^T\gamma_t(j)}{\sum_{t=1}^T\gamma_t(j)} \]
</p>

<p>
Iteration consists of E step and M step. In the E-step, \(\gamma_t\) and \(\xi_t\) are computed, and then new estimates for \(\hat{a}_{ij}\) and \(\hat{b}_j(v_k)\) are computed.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
<p>
Exercises 9.1 and 9.2:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">ns</span> <span class="org-type">exercises-9</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">hmm</span>
  <span class="org-rainbow-delimiters-depth-2">[]</span>
  <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"START"</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:op</span> <span class="org-rainbow-delimiters-depth-4">{}</span>
            <span class="org-clojure-keyword">:edges</span> <span class="org-rainbow-delimiters-depth-4">{}</span><span class="org-rainbow-delimiters-depth-3">}</span>
   <span class="org-string">"END"</span> <span class="org-rainbow-delimiters-depth-3">{</span><span class="org-clojure-keyword">:op</span> <span class="org-rainbow-delimiters-depth-4">{}</span>
          <span class="org-clojure-keyword">:edges</span> <span class="org-rainbow-delimiters-depth-4">{}</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">add-node</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm node<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">op = observation probability</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>conj hmm <span class="org-rainbow-delimiters-depth-3">{</span>node <span class="org-rainbow-delimiters-depth-4">{</span><span class="org-clojure-keyword">:op</span> <span class="org-rainbow-delimiters-depth-5">{}</span>
                   <span class="org-clojure-keyword">:edges</span> <span class="org-rainbow-delimiters-depth-5">{}</span><span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">add-obs-prob</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm node obs cost<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>assoc-in hmm <span class="org-rainbow-delimiters-depth-3">[</span>node <span class="org-clojure-keyword">:op</span> obs<span class="org-rainbow-delimiters-depth-3">]</span> cost<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">add-edge</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm start end weight<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>assoc-in hmm <span class="org-rainbow-delimiters-depth-3">[</span>start <span class="org-clojure-keyword">:edges</span> end<span class="org-rainbow-delimiters-depth-3">]</span> weight<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">nodes</span>
  <span class="org-doc">"Names of all nodes in the HMM"</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>keys hmm<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">obs-prob</span>
  <span class="org-doc">"P(o|q). If not defined, nil."</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm node obs<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>get-in hmm <span class="org-rainbow-delimiters-depth-3">[</span>node <span class="org-clojure-keyword">:op</span> obs<span class="org-rainbow-delimiters-depth-3">]</span> <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">transition-prob</span>
  <span class="org-doc">"Probability of transitioning from start to end. If not defined, 0."</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm start end<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>get-in hmm <span class="org-rainbow-delimiters-depth-3">[</span>start <span class="org-clojure-keyword">:edges</span> end<span class="org-rainbow-delimiters-depth-3">]</span> <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">parent-nodes</span>
  <span class="org-doc">"Returns dict where keys are nodes and values are the probability of</span>
<span class="org-doc">   transitioning from that node to a given node. Note that this algorithm</span>
<span class="org-doc">   is inefficient. If this were real, we'd find a space trade-off to make</span>
<span class="org-doc">   this operation O(1)."</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm given-node<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>reduce <span class="org-rainbow-delimiters-depth-3">(</span>fn <span class="org-rainbow-delimiters-depth-4">[</span>d <span class="org-rainbow-delimiters-depth-5">[</span>node <span class="org-rainbow-delimiters-depth-6">{</span><span class="org-clojure-keyword">:keys</span> <span class="org-rainbow-delimiters-depth-7">[</span>edges<span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">}</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if-let</span> <span class="org-rainbow-delimiters-depth-5">[</span>p <span class="org-rainbow-delimiters-depth-6">(</span>get edges given-node<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">]</span>
              <span class="org-rainbow-delimiters-depth-5">(</span>assoc d node p<span class="org-rainbow-delimiters-depth-5">)</span>
              d<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
          <span class="org-rainbow-delimiters-depth-3">{}</span>
          hmm<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">prob-of-transition-from</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm node start<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>get <span class="org-rainbow-delimiters-depth-3">(</span>parent-nodes hmm node<span class="org-rainbow-delimiters-depth-3">)</span> start <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>


<span class="org-comment-delimiter">;; </span><span class="org-comment">algorithms ------------------------------------------------------------</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">forward</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">fwd-init-alphas</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>reduce <span class="org-rainbow-delimiters-depth-3">(</span>fn <span class="org-rainbow-delimiters-depth-4">[</span>alphas node<span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-rainbow-delimiters-depth-4">(</span>assoc alphas
                   node
                   <span class="org-rainbow-delimiters-depth-5">(</span>* <span class="org-rainbow-delimiters-depth-6">(</span>prob-of-transition-from hmm node <span class="org-string">"START"</span><span class="org-rainbow-delimiters-depth-6">)</span>
                      <span class="org-rainbow-delimiters-depth-6">(</span>obs-prob hmm node obs<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
          <span class="org-rainbow-delimiters-depth-3">{}</span>
          <span class="org-rainbow-delimiters-depth-3">(</span>nodes hmm<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">fwd-update-alpha</span>
  <span class="org-doc">"For a given node and a given observation, generate a new alpha"</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm alphas obs new-alphas cur-node<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-3">(</span>parent-nodes hmm cur-node<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>map <span class="org-rainbow-delimiters-depth-4">(</span>fn <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-rainbow-delimiters-depth-6">[</span>pnode transition-prob<span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">]</span>
              <span class="org-rainbow-delimiters-depth-5">(</span>* <span class="org-rainbow-delimiters-depth-6">(</span>get alphas pnode <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-6">)</span>
                 transition-prob
                 <span class="org-rainbow-delimiters-depth-6">(</span>obs-prob hmm cur-node obs<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>reduce +<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>assoc new-alphas cur-node<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">fwd-inner</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs-seq<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">tail-recursive loop: iterate over each obs, updating the alphas</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-3">[</span>alphas <span class="org-rainbow-delimiters-depth-4">(</span>fwd-init-alphas hmm <span class="org-rainbow-delimiters-depth-5">(</span>first obs-seq<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">[</span>obs &amp; remaining-obs<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">(</span>rest obs-seq<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>nil? obs<span class="org-rainbow-delimiters-depth-4">)</span>
      alphas
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">recur</span>
       <span class="org-rainbow-delimiters-depth-5">(</span>reduce <span class="org-rainbow-delimiters-depth-6">(</span>partial fwd-update-alpha hmm alphas obs<span class="org-rainbow-delimiters-depth-6">)</span>
               <span class="org-rainbow-delimiters-depth-6">{}</span>
               <span class="org-rainbow-delimiters-depth-6">(</span>nodes hmm<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
       remaining-obs<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">fwd-terminate</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm alphas<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>reduce <span class="org-rainbow-delimiters-depth-3">(</span>fn <span class="org-rainbow-delimiters-depth-4">[</span>sum <span class="org-rainbow-delimiters-depth-5">[</span>node alpha<span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-rainbow-delimiters-depth-4">(</span>+ sum
               <span class="org-rainbow-delimiters-depth-5">(</span>* alpha
                  <span class="org-rainbow-delimiters-depth-6">(</span>transition-prob hmm node <span class="org-string">"END"</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
          <span class="org-highlight-numbers-number">0</span>
          alphas<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">fwd</span>
  <span class="org-doc">"Takes an HMM and a sequence of observations and calculates the</span>
<span class="org-doc">   probability assigned to the obs seq."</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs-seq<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>alphas <span class="org-rainbow-delimiters-depth-4">(</span>fwd-inner hmm obs-seq<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>fwd-terminate hmm alphas<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">viterbi</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">instead of alphas we use pairs--this is just a 2-vector of the previous</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">node name with the current node's alpha</span>
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">vtb-init-pairs</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span>reduce <span class="org-rainbow-delimiters-depth-3">(</span>fn <span class="org-rainbow-delimiters-depth-4">[</span>pairs node<span class="org-rainbow-delimiters-depth-4">]</span>
            <span class="org-rainbow-delimiters-depth-4">(</span>assoc pairs
                   node
                   <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">"START"</span>
                    <span class="org-rainbow-delimiters-depth-6">(</span>* <span class="org-rainbow-delimiters-depth-7">(</span>prob-of-transition-from hmm node <span class="org-string">"START"</span><span class="org-rainbow-delimiters-depth-7">)</span>
                       <span class="org-rainbow-delimiters-depth-7">(</span>obs-prob hmm node obs<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
          <span class="org-rainbow-delimiters-depth-3">{}</span>
          <span class="org-rainbow-delimiters-depth-3">(</span>nodes hmm<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">vtb-update-pair</span>
  <span class="org-doc">"For a given node and a given observation, generate a new pair"</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm pairs obs new-pairs cur-node<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if-let</span> <span class="org-rainbow-delimiters-depth-3">[</span>new-pair <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-5">(</span>parent-nodes hmm cur-node<span class="org-rainbow-delimiters-depth-5">)</span>
                         <span class="org-rainbow-delimiters-depth-5">(</span>map <span class="org-rainbow-delimiters-depth-6">(</span>fn <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-rainbow-delimiters-depth-8">[</span>pnode transition-prob<span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span>
                                <span class="org-rainbow-delimiters-depth-7">[</span>pnode
                                 <span class="org-rainbow-delimiters-depth-8">(</span>* <span class="org-rainbow-delimiters-depth-9">(</span><span class="org-keyword">or</span> <span class="org-rainbow-delimiters-depth-1">(</span>some-&gt;&gt; <span class="org-rainbow-delimiters-depth-2">(</span>get pairs pnode<span class="org-rainbow-delimiters-depth-2">)</span>
                                                 second<span class="org-rainbow-delimiters-depth-1">)</span>
                                        <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-9">)</span>
                                    transition-prob
                                    <span class="org-rainbow-delimiters-depth-9">(</span>obs-prob hmm cur-node obs<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                         <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-rainbow-delimiters-depth-6">(</span>fn <span class="org-rainbow-delimiters-depth-7">[</span>pairs<span class="org-rainbow-delimiters-depth-7">]</span>
                            <span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-8">(</span>empty? pairs<span class="org-rainbow-delimiters-depth-8">)</span>
                              <span class="org-constant">nil</span>
                              <span class="org-rainbow-delimiters-depth-8">(</span>reduce <span class="org-rainbow-delimiters-depth-9">(</span>fn <span class="org-rainbow-delimiters-depth-1">[</span>max n<span class="org-rainbow-delimiters-depth-1">]</span>
                                        <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-2">(</span>&gt; <span class="org-rainbow-delimiters-depth-3">(</span>second n<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>second max<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
                                          n
                                          max<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-9">)</span>
                                      pairs<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>assoc new-pairs cur-node new-pair<span class="org-rainbow-delimiters-depth-3">)</span>
    new-pairs<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">vtb-inner</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs-seq<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">tail-recursive loop: iterate over each obs, updating the pairs</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-3">[</span>backtrace '<span class="org-rainbow-delimiters-depth-4">()</span>
         pairs <span class="org-rainbow-delimiters-depth-4">(</span>vtb-init-pairs hmm <span class="org-rainbow-delimiters-depth-5">(</span>first obs-seq<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">[</span>obs &amp; remaining-obs<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">(</span>rest obs-seq<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-4">(</span>nil? obs<span class="org-rainbow-delimiters-depth-4">)</span>
      <span class="org-rainbow-delimiters-depth-4">[</span>pairs backtrace<span class="org-rainbow-delimiters-depth-4">]</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-5">[</span>pairs <span class="org-rainbow-delimiters-depth-6">(</span>reduce <span class="org-rainbow-delimiters-depth-7">(</span>partial vtb-update-pair hmm pairs obs<span class="org-rainbow-delimiters-depth-7">)</span>
                          <span class="org-rainbow-delimiters-depth-7">{}</span>
                          <span class="org-rainbow-delimiters-depth-7">(</span>nodes hmm<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
            backtrace <span class="org-rainbow-delimiters-depth-6">(</span>cons <span class="org-rainbow-delimiters-depth-7">(</span>reduce <span class="org-rainbow-delimiters-depth-8">(</span>fn <span class="org-rainbow-delimiters-depth-9">[</span>bt <span class="org-rainbow-delimiters-depth-1">[</span>node <span class="org-rainbow-delimiters-depth-2">[</span>source-node _<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span><span class="org-rainbow-delimiters-depth-9">]</span>
                                      <span class="org-rainbow-delimiters-depth-9">(</span>assoc bt node source-node<span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span>
                                    <span class="org-rainbow-delimiters-depth-8">{}</span>
                                    pairs<span class="org-rainbow-delimiters-depth-7">)</span>
                            backtrace<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">]</span>
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">recur</span> backtrace pairs remaining-obs<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn-</span> <span class="org-function-name">vtb-terminate</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm pairs backtrace<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span>winning-node &amp; _<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">(</span>reduce <span class="org-rainbow-delimiters-depth-5">(</span>fn <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-rainbow-delimiters-depth-7">[</span>winner winner-prev winner-cost<span class="org-rainbow-delimiters-depth-7">]</span> <span class="org-rainbow-delimiters-depth-7">[</span>node <span class="org-rainbow-delimiters-depth-8">[</span>pnode alpha<span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span>
                                     <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-7">[</span>cost <span class="org-rainbow-delimiters-depth-8">(</span>* alpha <span class="org-rainbow-delimiters-depth-9">(</span>transition-prob hmm node <span class="org-string">"END"</span><span class="org-rainbow-delimiters-depth-9">)</span><span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">]</span>
                                       <span class="org-rainbow-delimiters-depth-7">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-8">(</span>&gt; cost winner-cost<span class="org-rainbow-delimiters-depth-8">)</span>
                                         <span class="org-rainbow-delimiters-depth-8">[</span>node pnode cost<span class="org-rainbow-delimiters-depth-8">]</span>
                                         <span class="org-rainbow-delimiters-depth-8">[</span>winner winner-prev winner-cost<span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                                   <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">"ERR"</span> <span class="org-string">"ERR"</span> <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-5">]</span>
                                   pairs<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-4">[</span>node winning-node
           backtrace backtrace
           path '<span class="org-rainbow-delimiters-depth-5">()</span><span class="org-rainbow-delimiters-depth-4">]</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span>nil? node<span class="org-rainbow-delimiters-depth-5">)</span>
        path
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">recur</span>
         <span class="org-rainbow-delimiters-depth-6">(</span>get <span class="org-rainbow-delimiters-depth-7">(</span>first backtrace<span class="org-rainbow-delimiters-depth-7">)</span> node<span class="org-rainbow-delimiters-depth-6">)</span>
         <span class="org-rainbow-delimiters-depth-6">(</span>rest backtrace<span class="org-rainbow-delimiters-depth-6">)</span>
         <span class="org-rainbow-delimiters-depth-6">(</span>cons node path<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">vtb</span>
  <span class="org-doc">"Takes an HMM and a sequence of observations and calculates the</span>
<span class="org-doc">   probability assigned to the obs seq."</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>hmm obs-seq<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span>pairs backtrace<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">(</span>vtb-inner hmm obs-seq<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>vtb-terminate hmm pairs backtrace<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>


<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">-main</span>
  <span class="org-rainbow-delimiters-depth-2">[]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>hmm1 <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-5">(</span>hmm<span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-node <span class="org-string">"hot"</span><span class="org-rainbow-delimiters-depth-5">)</span>  <span class="org-comment-delimiter">;; </span><span class="org-comment">"START" and "END" already added</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-node <span class="org-string">"cold"</span><span class="org-rainbow-delimiters-depth-5">)</span>

                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"START"</span> <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">0.8</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"START"</span> <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">0.2</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"hot"</span> <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">0.6</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"hot"</span> <span class="org-string">"END"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"hot"</span> <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">0.3</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"cold"</span> <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">0.5</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"cold"</span> <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">0.4</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"cold"</span> <span class="org-string">"END"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span>

                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">0.2</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">0.4</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"hot"</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">0.4</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">0.5</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">0.4</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        hmm2 <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-5">(</span>hmm<span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-node <span class="org-string">"healthy"</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-node <span class="org-string">"fever"</span><span class="org-rainbow-delimiters-depth-5">)</span>

                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"START"</span> <span class="org-string">"healthy"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.6</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"START"</span> <span class="org-string">"fever"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.4</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"healthy"</span> <span class="org-string">"healthy"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.7</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"healthy"</span> <span class="org-string">"fever"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.3</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"fever"</span> <span class="org-string">"fever"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.6</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"fever"</span> <span class="org-string">"healthy"</span> <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-highlight-numbers-number">0.4</span> <span class="org-highlight-numbers-number">0.9</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>

                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"fever"</span> <span class="org-string">"END"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-edge <span class="org-string">"healthy"</span> <span class="org-string">"END"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span>

                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"healthy"</span> <span class="org-string">"dizzy"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"healthy"</span> <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">0.4</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"healthy"</span> <span class="org-string">"normal"</span> <span class="org-highlight-numbers-number">0.5</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"fever"</span> <span class="org-string">"dizzy"</span> <span class="org-highlight-numbers-number">0.6</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"fever"</span> <span class="org-string">"cold"</span> <span class="org-highlight-numbers-number">0.3</span><span class="org-rainbow-delimiters-depth-5">)</span>
                 <span class="org-rainbow-delimiters-depth-5">(</span>add-obs-prob <span class="org-string">"fever"</span> <span class="org-string">"normal"</span> <span class="org-highlight-numbers-number">0.1</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>fwd hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 0.002193...</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>fwd hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1.5832...e-6</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>fwd hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; 1.7264...e-6</span>

    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>vtb hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (hot hot hot)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>vtb hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (hot hot cold cold hot hot hot hot hot)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>vtb hmm1 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (hot hot cold cold hot hot hot cold cold)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>println <span class="org-rainbow-delimiters-depth-4">(</span>vtb hmm2 '<span class="org-rainbow-delimiters-depth-5">(</span><span class="org-string">"normal"</span> <span class="org-string">"cold"</span> <span class="org-string">"dizzy"</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">;;</span><span class="org-comment">=&gt; (healthy healthy fever)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>-main<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
<style>
body { 
    max-width: 800px; 
    margin: 0 auto 0 auto;
} 
</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>


<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.2 Context Free Grammars</h3>
<div class="outline-text-3" id="text-">
<p>
A grammar is defined by a 4-tuple: 
</p>

<ul class="org-ul">
<li>\(N\), a set of non-terminals
</li>
<li>\(\Sigma\), a set of terminals
</li>
<li>\(R\), a set of productions \(A\rightarrow \beta\) where \(A\) is non-terminal and \(\beta\) is a string of symbols from the infinite set of strings \((\Sigma \cup N)*\)
</li>
<li>\(S \in N\), a designated start symbol
</li>
</ul>

<p>
Direct derivation: if \(A \rightarrow \beta \in R\) and \(\alpha, \gamma \in (\Sigma \cup N)*\), then \(\alpha A\gamma\) directly derives \(\alpha\beta\gamma\), or \(\alpha A\gamma \Rightarrow \alpha\beta\gamma \)
</p>

<p>
Derivation, a generalization of direct derivation: if \(\alpha_1,...,\alpha_m \in (\Sigma\cup N)*, m \geq 1\), such that \(\alpha_1 \Rightarrow \alpha_2\alpha_3 \Rightarrow \alpha_3,\ldots,\alpha_{m-1} \Rightarrow \alpha_m\), then \(\alpha_1\) derives \(\alpha_m\), or \(\alpha_1 \overset{*}{\Rightarrow} \alpha_m\)
</p>

<p>
So the corresponding language \(\mathscr{L}_G = \{w|w \in \Sigma* \wedge S \overset{*}{\Rightarrow} w\}\), i.e. the set of all terminal strings that can be derived using productions in \(R\).
</p>
</div>
</div>


<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.5 Grammar Equivalence and Normal Form</h3>
<div class="outline-text-3" id="text-">
<p>
Two kinds of grammar equivalence:
</p>

<ul class="org-ul">
<li>Weak equivalence: same set of terminal strings
</li>
<li>Strong equivalence: same set of terminal strings and same phrase structure
</li>
</ul>

<p>
Sometimes normal forms are useful. Chomsky normal form is \(\epsilon\)-free, and all productions have either two non-terminals or one terminal. (This makes it binary branching.)
</p>

<p>
Any CFG can be turned into a weakly equivalent CNF grammar. E.g., \(A \rightarrow B C D \Rightarrow A \rightarrow B X, X \rightarrow C D\).
</p>

<p>
Generating a symbol A with a potentially infinite sequence of symbols B with a rule of form \(A \rightarrow A B\) is known as Chomsky-adjunction.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.6 Lexicalized Grammars</h3>
<div class="outline-text-3" id="text-">
<p>
CFG's and related approaches minimize the role of the lexicon, leads to brittleness and redundancy. Other approaches make more use of the lexicon.
</p>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">10.6.1 Combinatory Categorial Grammar</h4>
<div class="outline-text-4" id="text-">
<p>
<b>Categories</b>: either atoms or single-argument functions that return a category when provided with a desired category. Set of categories \(\mathscr{C}\) defined as:
</p>

<ul class="org-ul">
<li>\(\mathscr{A} \subseteq \mathscr{C}\), where \(\mathscr{A}\) is a set of atomic elements
</li>
<li>\((X/Y), (X\backslash Y) \in \mathscr{C}\), if \(X,Y \in \mathscr{C}\)
</li>
</ul>

<p>
\((X/Y)\) means "seeks a constituent of type \(Y\) to its right and returns a value of \(X\)". \((X\backslash Y)\) means the same, but it seeks the constituent of type \(Y\) to the left. Atomic categories are small and contain familiar parts of speech.
</p>

<p>
<b>Lexicon</b>: words are assigned categories, e.g. \((S\backslash NP)/NP\) anticipating a production like "cancel the flight to Miami".
</p>

<p>
<b>Rules</b>: specify how functions and their arguments combine. Based on two templates:
</p>

<p>
\[ X / Y\ Y \Rightarrow X \]
</p>

<p>
\[ Y\ X\backslash Y \Rightarrow X \]
</p>

<p>
This is just a restatement of what we showed earlier: if a Y is encountered to the right of the function, it will emit an X, etc. Need another rule to handle coordination:
</p>

<p>
\[ X\ CONJ\ X \Rightarrow X \]
</p>

<p>
Note that the \(CONJ\) category is not emitted.
</p>

<p>
<b>More power</b>: so far only have as much power as CFG's. But CCG has more powerful operations. E.g., function composition:
</p>

<p>
\[ X/Y\ Y/Z \Rightarrow X/Z \]
</p>

<p>
\[ Y\backslash Z\ X\backslash Y \Rightarrow X\backslash Z \]
</p>

<p>
Type raising: takes a category and turns it into a function that takes the original category as its argument:
</p>

<p>
\[ X \Rightarrow T/(T\backslash X) \]
</p>

<p>
\[ X \Rightarrow T\backslash (T/X) \]
</p>

<p>
Both demonstrated here. Former rule indicated by the B, latter indicated by the T:
</p>


<figure>
<p><img src="./ltximg/unitedservesmiami.png" class="img-responsive" alt="unitedservesmiami.png">
</p>
</figure>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.3</h3>
<div class="outline-text-3" id="text-">
<p>
The rules we were given are:
</p>

\begin{array}{lll}
Nominal & \rightarrow & Nominal\ RelClause \\
RelClause & \rightarrow & (who\ |\ that)\ VP \\
VP & \rightarrow & VP_1 \\
VP & \rightarrow & VP_2 \\
\vdots & \rightarrow & \vdots \\
\end{array}

<p>
There are two problems with these rule for the sentence <i>the earliest flight that you have</i>. First, this production does not contain any NP's for the word <i>you</i>, and second, since the verb's complement is <i>who</i> or <i>that</i>, we need to alter the production rules so that complements are not allowed in this kind of relative clause. (We won't try to account for movement.)
</p>

<p>
We can fix the NP problem by adding an additional production that contains an NP before the VP. 
</p>

<p>
The most straightforward fix for the complement removal problem is to create a duplicate of every VP subcategorization that includes a complement and to remove the complement from the corresponding duplicate. Then, we would nest this under a new VP-like category that is just for relative clauses. (We could also inline this by writing \((RCVP_1 | RCVP_2 | \ldots | RCVP_n)\) instead of \(RCVP\).)
</p>

<p>
Our new rules:
</p>

\begin{array}{lll}
Nominal & \rightarrow & Nominal\ RelClause \\
RelClause & \rightarrow & (who\ |\ that)\ NP\ RCVP \\
RelClause & \rightarrow & (who\ |\ that)\ RCVP \\
RCVP & \rightarrow & RCVP_1 \\
RCVP & \rightarrow & RCVP_2 \\
\vdots & \rightarrow & \vdots \\
\end{array}

<p>
Take one subcategory we might have had originally&#x2013;let's call it \(VPCmpl\)&#x2013;and compare it to its relativized form:
</p>

\begin{array}{lll}
VP & \rightarrow & VPCmpl \\
VPCmpl & \rightarrow & Verb\ NP \\
RCVP & \rightarrow & RCVPCmpl \\
RCVPCmpl & \rightarrow & Verb \\
\end{array}

<p>
Thus, using the first set of rules we can correctly form a normal sentence like \([_{S} [_{NP} \text{ We}] [_{VP} \text{ have} [_{NP} \text{ the earliest flight}]]]\), and we correctly reject a formation like \(*[_{S} [_{NP} \text{ We}] [_{VP} \text{ have}]]\).
</p>

<p>
Analogously, using the second set of rules: the sentence 
</p>

<p>
\[[_{NP} [_{Det} \text{ the}] [_{Nom} [_{Nom} [_{Nom} [_{Adj} \text{ earliest}]] [_{Nom} [_{Noun} \text{ flight}]]] [_{RelClause} \text{ that} [_{NP} [_{Nom} [_{Noun} \text{ you}]]] [_{RCVP} [_{RCVPCmpl} [_{Verb} \text{ have}]]]]]]\] 
</p>

<p>
is generated correctly, but a sentence like <i>the earliest flight that you have it</i> is rejected.
</p>
</div>
</div>




<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.4</h3>
<div class="outline-text-3" id="text-">
<p>
<i>the earliest flight that I can get</i> works fine because we added an \(NP\) to the \(RelClause\) production. 
</p>

<p>
<i>the earliest flight that I think my mother wants me to book for her</i> doesn't work with our straightforward approach from before, because only <i>one</i> complement out of potentially many may be moved to the head of the relative clause&#x2013;i.e., represented by <i>that</i>, <i>who</i>, etc. 
</p>

<p>
First, the <i>I</i> would parse as an NP. Note that the rest of the sentence, <i>think my mother wants me to book for her</i>, is analogous to <i>think my mother wants me to book [a flight] for her</i> in the non-relative clause version you'd find in a declarative sentence. Then this, too, can be parsed as something like this (some simplifications were made to irrelevant structures):
</p>

<p>
\[ [_{VPRC_{think}} \text{ think} [_{S_{rel}} [_{NP} \text{ my mother}] [_{VPRC_{wants}} \text{ wants} [_{NP} \text{ me}] [_{VPRC_{to}} \text{ to book for her}]]]]\]
</p>

<p>
Compare this with its non-relative analogue:
</p>

<p>
\[ [_{VP_{think}} \text{ think} [_{S} [_{NP} \text{ my mother}] [_{VP_{wants}} \text{ wants} [_{NP} \text{ me}] [_{VP_{to}} \text{ to book }\textbf{a flight}\text{ for her}]]]]\]
</p>

<p>
Note we are assuming that we have subcategories for constructions we're calling <i>think</i>, <i>wants</i>, and <i>to</i>. The <i>to</i> VP has had its complement removed in its relative clause analogue, but the other two have not had their complements removed. But they <i>can</i> have their complements, as well as some other constituents, removed. Consider these movements, which affect all three constructions:
</p>

<ul class="org-ul">
<li>The flight that I think my mother wants me to book \([\varnothing]\) for her
</li>
<li>The uncle who I think my mother wants me to book the flight for \([\varnothing]\)
</li>
<li>My mother who I think \([\varnothing]\) wants me to book a flight for her
</li>
<li>He who I think my mother wants \([\varnothing]\) to book the flight for her
</li>
<li>I who \([\varnothing]\) think my mother wants me to book the flight for her
</li>
</ul>

<p>
So long as there's only one constituent that has moved, we could devise a new set of subcategories. First, we would wrap the subject \(NP\) and the verbal part of the construction in a new clause constituent such that for each \(RCC_n\) there is also a \(RCC_{n,moved,i}\), where the <i>moved,i</i> variant indicates the the \(i\)th immediate child of the construction has been moved, and a \(RCC_{n,blocked}\) that indicates a previous construction participated in movement and therefore this one may not. While unwieldy, this could produce correct results, at least with respect to this problem. This is an example parse of <i>My mother who I think wants me to a book a flight for her</i>:
</p>


<p>
\[ [_{RelClause} \text{ who} [_{RCC_{think}} [_{NP} \text{ I}] [_{VP} \text{ think} [_{RCC_{wants,moved,1}} [_{NP} \varnothing] [_{VP} \text{ wants} [_{NP} \text{ me}]  \]
\[ [_{RCC_{book,blocked}} \text{ to} [_{VP} \text{ book} [_{NP} \text{ the flight}] [_{PP} \text{ for her}]]]]]]]] \]
</p>

<p>
Needless to say, this is a pretty brittle solution.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.5</h3>
<div class="outline-text-3" id="text-">
\begin{array}{lll}
verb-with-bare-VP-complement & \rightarrow & \text{can | could | may | might | shall | should | will | would}\\
verb-with-infinitive-VP-complement & \rightarrow &  \text{ought} \\
verb-with-gerundive-VP-complement & \rightarrow & \text{is | are} \\
verb-with-perfective-VP-complement & \rightarrow & \text{has | have | is | are} \\
\end{array}
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">10.6</h3>
<div class="outline-text-3" id="text-">
\begin{array}{lll}
Det & \rightarrow & NP\ Gen \\
Gen & \rightarrow & \text{'s} \\
\end{array}

<p>
\[ [_{NP} [_{Det} [_{NP} [_{Nom} [_{Noun} \text{Fortune}]]] [_{Gen} \text{'s}]] [_{Nom} [_{Noun} \text{ office}]]] \]
</p>
<style>
body { 
    max-width: 800px; 
    margin: 0 auto 0 auto;
} 
img { width: 100%; }
</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>
</div>


<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
<p>
Exercises 11.1 and 11.2:
</p>

<div class="org-src-container">

<pre class="src src-python"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint

<span class="org-keyword">class</span> <span class="org-type">CFG</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-builtin">object</span><span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions = <span class="org-rainbow-delimiters-depth-1">[]</span>

    <span class="org-keyword">def</span> <span class="org-function-name">productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._productions

    <span class="org-keyword">def</span> <span class="org-function-name">add_production</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs, rhs<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">def</span> <span class="org-function-name">find_productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, target_lhs<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-variable-name">tmp</span> = <span class="org-rainbow-delimiters-depth-1">[]</span>
        <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions:
            <span class="org-keyword">if</span> lhs == target_lhs:
                tmp.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs, rhs<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
        <span class="org-keyword">return</span> tmp

    <span class="org-keyword">def</span> <span class="org-function-name">only_produced_by_units</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, target_lhs<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-doc">"""Returns true if (a) there is at least one unit production that produces</span>
<span class="org-doc">        the argument, and (b) there are only unit productions that produce it. """</span>
        <span class="org-variable-name">appears</span> = <span class="org-constant">False</span>
        <span class="org-keyword">for</span> _, rhs <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions:
            <span class="org-keyword">if</span> target_lhs <span class="org-keyword">in</span> rhs:
                <span class="org-variable-name">appears</span> = <span class="org-constant">True</span>
                <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> &gt; <span class="org-highlight-numbers-number">1</span>:
                    <span class="org-keyword">return</span> <span class="org-constant">False</span>
        <span class="org-keyword">return</span> appears

    <span class="org-keyword">def</span> <span class="org-function-name">sort</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions.sort<span class="org-rainbow-delimiters-depth-1">(</span>key=<span class="org-keyword">lambda</span> x:x<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">just checking for lhs, not the entire rule</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__contains__</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, target_lhs<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">for</span> lhs, _ <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions:
            <span class="org-keyword">if</span> target_lhs == lhs:
                <span class="org-keyword">return</span> <span class="org-constant">True</span>
        <span class="org-keyword">return</span> <span class="org-constant">False</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">all methods below here are used for CKY parsing. Some of them will have</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">worse time performance than they need to (like many of the methods above),</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">and could be solved with indexes or other means in a practical system.</span>
    <span class="org-keyword">def</span> <span class="org-function-name">find_unit_word_productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, word<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-doc">"""Given a word, return a list of all left hand sides for rules that</span>
<span class="org-doc">        produce ONLY the word on the right hand side."""</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span>lhs <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions \
                <span class="org-keyword">if</span> rhs == <span class="org-rainbow-delimiters-depth-2">[</span>word<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>

    <span class="org-keyword">def</span> <span class="org-function-name">find_compatible_binary_productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, rhs1, rhs2<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span>lhs <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions \
                <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-2">(</span>rhs<span class="org-rainbow-delimiters-depth-2">)</span> == <span class="org-highlight-numbers-number">2</span> <span class="org-keyword">and</span> rhs<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">in</span> rhs1 <span class="org-keyword">and</span> rhs<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">in</span> rhs2<span class="org-rainbow-delimiters-depth-1">]</span>


<span class="org-keyword">def</span> <span class="org-function-name">cnf_gen_symbol</span><span class="org-rainbow-delimiters-depth-1">(</span>g<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-variable-name">pre</span> = <span class="org-string">"X"</span>
    <span class="org-variable-name">n</span> = <span class="org-highlight-numbers-number">1</span>
    <span class="org-keyword">while</span> <span class="org-rainbow-delimiters-depth-1">(</span>pre + <span class="org-builtin">str</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">in</span> g:
        <span class="org-variable-name">n</span> += <span class="org-highlight-numbers-number">1</span>
    <span class="org-keyword">return</span> pre + <span class="org-builtin">str</span><span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">def</span> <span class="org-function-name">cnf_flatten</span><span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> g.productions<span class="org-rainbow-delimiters-depth-1">()</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">check to make sure it's a unit production</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> != <span class="org-highlight-numbers-number">1</span>:
            <span class="org-keyword">continue</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">We need to flatten top-level symbols and symbols that are produced in non-unit</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">productions, but we want to skip symbols that are ONLY produced by unit productions</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">since they will be handled by recursing on the former</span>
        <span class="org-keyword">if</span> g.only_produced_by_units<span class="org-rainbow-delimiters-depth-1">(</span>lhs<span class="org-rainbow-delimiters-depth-1">)</span>:
            <span class="org-keyword">continue</span>
        cnf_flatten_dfs<span class="org-rainbow-delimiters-depth-1">(</span>g, new_g, lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">def</span> <span class="org-function-name">cnf_flatten_dfs</span><span class="org-rainbow-delimiters-depth-1">(</span>g, new_g, orig_lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-doc">"""for simplicity, we assume there are no cycles"""</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-highlight-numbers-number">2</span>:
        new_g.add_production<span class="org-rainbow-delimiters-depth-1">(</span>orig_lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-highlight-numbers-number">1</span>:
        <span class="org-variable-name">rhs_val</span> = rhs<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>

        <span class="org-comment-delimiter"># </span><span class="org-comment">need to keep going if there are more productions from this unit prod</span>
        <span class="org-keyword">if</span> rhs_val <span class="org-keyword">in</span> g:
            <span class="org-keyword">for</span> _, new_rhs <span class="org-keyword">in</span> g.find_productions<span class="org-rainbow-delimiters-depth-1">(</span>rhs_val<span class="org-rainbow-delimiters-depth-1">)</span>:
                cnf_flatten_dfs<span class="org-rainbow-delimiters-depth-1">(</span>g, new_g, orig_lhs, new_rhs<span class="org-rainbow-delimiters-depth-1">)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">otherwise, we've found the leaf and we're done</span>
        <span class="org-keyword">else</span>:
            new_g.add_production<span class="org-rainbow-delimiters-depth-1">(</span>orig_lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">def</span> <span class="org-function-name">cnf_copy</span><span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-doc">"""Copy rules that don't need modification"""</span>
    <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> g.productions<span class="org-rainbow-delimiters-depth-1">()</span>:
        <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> == <span class="org-highlight-numbers-number">2</span>:
            new_g.add_production<span class="org-rainbow-delimiters-depth-1">(</span>lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">def</span> <span class="org-function-name">cnf_binarize</span><span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-doc">"""Introduce dummy nodes and rewrite rules so they are binary if they</span>
<span class="org-doc">    produce non-terminals"""</span>
    <span class="org-keyword">for</span> lhs, rhs <span class="org-keyword">in</span> g.productions<span class="org-rainbow-delimiters-depth-1">()</span>:
        <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> &lt;= <span class="org-highlight-numbers-number">2</span>:
            <span class="org-keyword">continue</span>
        <span class="org-keyword">while</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>rhs<span class="org-rainbow-delimiters-depth-1">)</span> &gt; <span class="org-highlight-numbers-number">2</span>:
            <span class="org-variable-name">new_prod</span> = cnf_gen_symbol<span class="org-rainbow-delimiters-depth-1">(</span>new_g<span class="org-rainbow-delimiters-depth-1">)</span>
            new_g.add_production<span class="org-rainbow-delimiters-depth-1">(</span>new_prod, rhs<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span>:<span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
            <span class="org-variable-name">rhs</span> = <span class="org-rainbow-delimiters-depth-1">[</span>new_prod<span class="org-rainbow-delimiters-depth-1">]</span> + rhs<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">2</span>:<span class="org-rainbow-delimiters-depth-1">]</span>
        new_g.add_production<span class="org-rainbow-delimiters-depth-1">(</span>lhs, rhs<span class="org-rainbow-delimiters-depth-1">)</span>


<span class="org-keyword">def</span> <span class="org-function-name">cnf</span><span class="org-rainbow-delimiters-depth-1">(</span>g<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-variable-name">new_g</span> = CFG<span class="org-rainbow-delimiters-depth-1">()</span>
    cnf_copy<span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>
    cnf_binarize<span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>
    cnf_flatten<span class="org-rainbow-delimiters-depth-1">(</span>g, new_g<span class="org-rainbow-delimiters-depth-1">)</span>
    new_g.sort<span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-comment-delimiter"># </span><span class="org-comment">for easier inspection of output</span>
    <span class="org-keyword">return</span> new_g

<span class="org-keyword">def</span> <span class="org-function-name">cky</span><span class="org-rainbow-delimiters-depth-1">(</span>g, words<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-doc">"""G is assumed to be in CNF."""</span>
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>words<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-highlight-numbers-number">1</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">initialize 2d matrix with an empty list in each cell</span>
    <span class="org-variable-name">m</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span><span class="org-builtin">set</span><span class="org-rainbow-delimiters-depth-3">()</span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>

    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>, n<span class="org-rainbow-delimiters-depth-1">)</span>:
        m<span class="org-rainbow-delimiters-depth-1">[</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span> = m<span class="org-rainbow-delimiters-depth-1">[</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span>.union<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-builtin">set</span><span class="org-rainbow-delimiters-depth-2">(</span>g.find_unit_word_productions<span class="org-rainbow-delimiters-depth-3">(</span>words<span class="org-rainbow-delimiters-depth-4">[</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>j-<span class="org-highlight-numbers-number">2</span>, -<span class="org-highlight-numbers-number">1</span>, -<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">)</span>:
            <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>i+<span class="org-highlight-numbers-number">1</span>, j<span class="org-rainbow-delimiters-depth-1">)</span>:
                m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span> = m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">]</span>.union<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-builtin">set</span><span class="org-rainbow-delimiters-depth-2">(</span>g.find_compatible_binary_productions<span class="org-rainbow-delimiters-depth-3">(</span>m<span class="org-rainbow-delimiters-depth-4">[</span>i<span class="org-rainbow-delimiters-depth-4">][</span>k<span class="org-rainbow-delimiters-depth-4">]</span>, m<span class="org-rainbow-delimiters-depth-4">[</span>k<span class="org-rainbow-delimiters-depth-4">][</span>j<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">for</span> x <span class="org-keyword">in</span> m:
        <span class="org-keyword">print</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-variable-name">g</span> = <span class="org-constant">None</span>
<span class="org-keyword">def</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>:
    <span class="org-keyword">global</span> g
    <span class="org-variable-name">g</span> = CFG<span class="org-rainbow-delimiters-depth-1">()</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"S"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"NP"</span>, <span class="org-string">"VP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"S"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Aux"</span>, <span class="org-string">"NP"</span>, <span class="org-string">"VP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"S"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"VP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"NP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Pronoun"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"NP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Proper-Noun"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"NP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Det"</span>, <span class="org-string">"Nominal"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Nominal"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Noun"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Nominal"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Nominal"</span>, <span class="org-string">"Noun"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Nominal"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Nominal"</span>, <span class="org-string">"PP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Verb"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Verb"</span>, <span class="org-string">"NP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Verb"</span>, <span class="org-string">"NP"</span>, <span class="org-string">"PP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Verb"</span>, <span class="org-string">"PP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"VP"</span>, <span class="org-string">"PP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"PP"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Preposition"</span>, <span class="org-string">"NP"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">terminals</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"that"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"this"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"the"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"a"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"book"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"flight"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"meal"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"money"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Verb"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"book"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Verb"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"include"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Verb"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"prefer"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Pronoun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"I"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Pronoun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"she"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Pronoun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"me"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Proper-Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Houston"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Proper-Noun"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"NWA"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Aux"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"does"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Preposition"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"from"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Preposition"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"to"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Preposition"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"on"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Preposition"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"near"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Preposition"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"through"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("a", ["c"])</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("b", ["c"])</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("c", ["d"])</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("d", ["e"])</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("e", ["f"])</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">g.add_production("e", ["g"])</span>

    <span class="org-variable-name">g</span> = cnf<span class="org-rainbow-delimiters-depth-1">(</span>g<span class="org-rainbow-delimiters-depth-1">)</span>
    <span class="org-comment-delimiter">#</span><span class="org-comment">pprint(g.productions())</span>
    cky<span class="org-rainbow-delimiters-depth-1">(</span>g, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"book"</span>, <span class="org-string">"the"</span>, <span class="org-string">"flight"</span>, <span class="org-string">"through"</span>, <span class="org-string">"Houston"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>


main<span class="org-rainbow-delimiters-depth-1">()</span>
</pre>
</div>
<style>
body { 
    max-width: 800px; 
    margin: 0 auto 0 auto;
} 
img { width: 100%; }
</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.1 Probabilistic CFG's</h3>
<div class="outline-text-3" id="text-">
<p>
PCFG's are like CFG's, but productions now have probabilities:
</p>

<ul class="org-ul">
<li>\(N\): a set of non-terminal symbols
</li>
<li>\(\Sigma\): a set of terminal symbols
</li>
<li>\(R\): a set of rules, \(A \rightarrow \beta\  [p]\), where \(A\) is a nonterminal, \(\beta\) is a string of symbols from the infinite set of strings \((\Sigma \cup N)*\), and \(p \in [0,1]\) expressing \(P(\beta|A)\)
</li>
<li>\(S\): the start symbol
</li>
</ul>

<p>
\(p = P(A\rightarrow \beta) = P(A\rightarrow\beta | A) = P(RHS|LHS)\). Note that this must be true:
</p>

<p>
\[ \sum_\beta P(A\rightarrow\beta) = 1 \]
</p>

<p>
PCFG is called consistent if sum of all possible expansions equals one.
</p>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Disambiguation</h4>
<div class="outline-text-4" id="text-">
<p>
Probabilities can be assigned to trees by taking the product of all productions used to construct it:
</p>

<p>
\[ P(T,S) = \prod_{i=1}^n P(RHS_i|LHS_i) \]
</p>

<p>
This is also \(P(T)\) because the tree includes all the words of the sentence:
</p>

<p>
\[ P(T,S) = P(T)P(S|T) = P(T) \]
</p>

<p>
To disambiguate, i.e. choose the best parse of multiple valid parses of the sentence, the tree with the highest \(P(T)\) is chosen:
</p>

<p>
\[ \hat{T}(S) = \underset{T\ s.t.\ S=\text{yield}(T)}{\text{argmax}} P(T|S) = \underset{T\ s.t.\ S=\text{yield}(T)}{\text{argmax}} P(T) \] 
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Language modeling</h4>
<div class="outline-text-4" id="text-">
<p>
The probability of a sentence is needed in many applications. This is the sum of the probabilities over all parse trees:
</p>

<p>
\[ P(S) = \sum_{T\ s.t.\ S=\text{yield}(T)} P(T) \]
</p>

<p>
Note that the sentence doesn't need to be complete: could be any string of words.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.2 Probabilistic CKY Parsing</h3>
<div class="outline-text-3" id="text-">
<p>
Algorithm is essentially the same, but contents of cells different. Each cell contains a third dimension of maximum length \(V\) (i.e., the number of non-terminals in the language). The \(i\)th slot in this third dimension corresponds to a non-terminal, and its value is the probability for that non-terminal at the given position. The probability of each cell is the product \(P(A\rightarrow BC) \times table[i,k,B] \times table[k,j,C]\).
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.3 Learning Production Probabilities</h3>
<div class="outline-text-3" id="text-">
<p>
If a treebank is provided, can use frequency:
</p>

<p>
\[ P(\alpha \rightarrow \beta|\alpha) = \frac{\text{Count}(\alpha\rightarrow\beta)}{\text{Count}(\alpha)} \]
</p>

<p>
If we have no treebank but do have a non-probabilistic parser, can use an iterative algorithm like inside-outside to improve probability estimates, related to forward-backward algorithm.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.4 PCFG problems</h3>
<div class="outline-text-3" id="text-">
<ul class="org-ul">
<li>Poor independence assumptions: some structures that are unusual most of the time are quite common in certain syntactic contexts and vice versa, but PCFG rules assign all productions a universal probability
</li>
<li>Lack of sensitivity to lexical dependencies: lexical items can also condition probabilities (e.g. by preferring VP to NP attachment for certain PP's), but PCFGs have no mechanism for allowing this
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.5 Splitting Non-Terminals to Address Independence Assumptions</h3>
<div class="outline-text-3" id="text-">
<p>
One missed opportunity: pronouns tend to be much more common as subjects rather than objects, but both are treated as NP's by our grammar.
</p>

<p>
One solution: split NP non-terminal into two versions: one for subject, one for object. Can be achieved by parent annotation: instead of NP, write NP<sup>S</sup>, NP<sup>VP</sup>, etc. Can do this with any kind of non-terminal.
</p>

<p>
Drawbacks: increases size of the grammar, and increases learning space, leading to overfitting. Need to strike a balance: used to be hand-split, but algorithms like split and merge automate splitting to maximize probability.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.6 Probabilistic Lexicalized CFGs</h3>
<div class="outline-text-3" id="text-">
<p>
Instead of splitting nodes, can multiply the productions by introducing a version of it for each possible "head tag" it could possess, where a "head tag" is the "most important" (intuitively) head of its child constituents. E.g., a rule like 
</p>

<p>
\[ VP \rightarrow VBD\ NP\ PP \]
</p>

<p>
could be enriched into something like this:
</p>

<p>
\[ VP(dumped,VBD) \rightarrow VBD(dumped,VBD)\ NP(sacks,NNS)\ PP(into,P) \]
</p>

<p>
Two kinds of rules to distinguish: lexical rules and internal rules. Lexical rules deterministic: lexicalized pre-terminal like \(NN(bin,NN)\) can only expand to the word \(bin\). But non-pre-terminals must be estimated.
</p>

<p>
How do we estimate probabilities? If we treat this as a regular PCFG with a <i>lot</i> of split nodes, clearly our space is too large for MLE to be a good idea. We need to break up the probability with independence assumptions:
</p>

<p>
\[ P(VP(dumped,VBD) \rightarrow VBD(dumped,VBD)\ NP(sacks,NNS)\ PP(into,P)) \]
</p>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Collins Parsing, simplified</h4>
<div class="outline-text-4" id="text-">
<p>
Collins parsing removes interdependence from non-head constituents:
</p>

\begin{array}{lll}
P_H(VBD|VP,dumped) & \times & P_L(STOP|VP,VBD,dumped) \\
& \times & P_R(NP(sacks,NNS)|VP,VBD,dumped) \\
& \times & P_R(PP(into,P)|VP,VBD,dumped) \\
& \times & P_R(STOP|VP,VBD,dumped) \\
\end{array}

<p>
Each is much easier to estimate from smaller amounts of data than the full probability.
</p>

<p>
Actual Collins parsing is more complicated, optionally distinguishing arguments from adjuncts and distance measures, among other things.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.7 Probabilistic CCG Parsing</h3>
<div class="outline-text-3" id="text-">
<p>
CKY is directly applicable to CCG parsing, but the multiplicity of possible lexical categories for a single word fills the table with many useless constituents. The solution is in finding the most likely lexical categories, a process called supertagging.
</p>

<p>
One approach: use MEMM to learn a probability distribution over possible supertags
</p>

<p>
Another: use A* to explore possible parses. \(g(n)\), the cost function, is defined as the joint probability of its supertags (ignoring the derivation):
</p>

\begin{array}{lll}
P(D,S) &=& P(T,S) \\
&=& \prod_{i=1}^nP(t_i|s_i) \\
&=& \sum_{i=1}^n -log P(t_i|s_i) \\
\end{array}

<p>
For \(h(n)\), which needs to always be less than or equal to the actual \(g(n)\), we use the probability of the most likely outside span.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.8 Evaluating Parsers</h3>
<div class="outline-text-3" id="text-">
<p>
Recall (correct hypothetical constituents/correct actual constituents), precision (correct constituents/total constitutents), and F-measure used as usual. Cross-bracket measure also usedwhich indicates the number of structures like (A (B C)) where ((A B) C) was actually correct.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
</div><div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">12.1 Probabilistic CKY</h3>
<div class="outline-text-3" id="text-">
<div class="org-src-container">

<pre class="src src-python"><span class="org-keyword">from</span> pprint <span class="org-keyword">import</span> pprint
<span class="org-keyword">from</span> collections <span class="org-keyword">import</span> defaultdict

<span class="org-keyword">class</span> <span class="org-type">PCFG</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-builtin">object</span><span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions = <span class="org-rainbow-delimiters-depth-1">[]</span>

    <span class="org-keyword">def</span> <span class="org-function-name">productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">return</span> <span class="org-keyword">self</span>._productions

    <span class="org-keyword">def</span> <span class="org-function-name">add_production</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, lhs, rhs, p<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions.append<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs, rhs, p<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">def</span> <span class="org-function-name">sort</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span><span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">self</span>._productions.sort<span class="org-rainbow-delimiters-depth-1">(</span>key=<span class="org-keyword">lambda</span> x:x<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">def</span> <span class="org-function-name">find_unit_word_productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, word<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-doc">"""Given a word, return a list of all left hand sides for rules that</span>
<span class="org-doc">        produce ONLY the word on the right hand side."""</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs, p<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">for</span> lhs, rhs, p <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions \
                <span class="org-keyword">if</span> rhs == <span class="org-rainbow-delimiters-depth-2">[</span>word<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>

    <span class="org-keyword">def</span> <span class="org-function-name">find_compatible_binary_productions</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">self</span>, prods1, prods2<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span>lhs, rhs, p<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">for</span> lhs, rhs, p <span class="org-keyword">in</span> <span class="org-keyword">self</span>._productions \
                <span class="org-keyword">if</span> <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-2">(</span>rhs<span class="org-rainbow-delimiters-depth-2">)</span> == <span class="org-highlight-numbers-number">2</span> <span class="org-keyword">and</span> prods1<span class="org-rainbow-delimiters-depth-2">[</span>rhs<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> &gt; <span class="org-highlight-numbers-number">0</span> <span class="org-keyword">and</span> prods2<span class="org-rainbow-delimiters-depth-2">[</span>rhs<span class="org-rainbow-delimiters-depth-3">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span> &gt; <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-keyword">def</span> <span class="org-function-name">build_tree</span><span class="org-rainbow-delimiters-depth-1">(</span>words, m, back, i, j, symbol<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-variable-name">trace</span> = back<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>symbol<span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-keyword">if</span> trace <span class="org-keyword">is</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span>symbol, words<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-variable-name">k</span> = trace<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-variable-name">b</span> = trace<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-variable-name">c</span> = trace<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">[</span>symbol,
            build_tree<span class="org-rainbow-delimiters-depth-2">(</span>words, m, back, i, k, b<span class="org-rainbow-delimiters-depth-2">)</span>,
            build_tree<span class="org-rainbow-delimiters-depth-2">(</span>words, m, back, k, j, c<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>

<span class="org-keyword">def</span> <span class="org-function-name">cky</span><span class="org-rainbow-delimiters-depth-1">(</span>g, words<span class="org-rainbow-delimiters-depth-1">)</span>:
    <span class="org-doc">"""G is assumed to be in CNF."""</span>
    <span class="org-variable-name">n</span> = <span class="org-builtin">len</span><span class="org-rainbow-delimiters-depth-1">(</span>words<span class="org-rainbow-delimiters-depth-1">)</span> + <span class="org-highlight-numbers-number">1</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">dict will map from non-terminals to probabilities</span>
    <span class="org-variable-name">m</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span>defaultdict<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span>: <span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
    <span class="org-variable-name">back</span> = <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">[</span>defaultdict<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">lambda</span>: <span class="org-constant">None</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-3">(</span>n<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-2">(</span>n<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>

    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">1</span>, n<span class="org-rainbow-delimiters-depth-1">)</span>:
        <span class="org-keyword">for</span> lhs, p <span class="org-keyword">in</span> g.find_unit_word_productions<span class="org-rainbow-delimiters-depth-1">(</span>words<span class="org-rainbow-delimiters-depth-2">[</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>:
            m<span class="org-rainbow-delimiters-depth-1">[</span>j-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>lhs<span class="org-rainbow-delimiters-depth-1">]</span> = p

        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>j-<span class="org-highlight-numbers-number">2</span>, -<span class="org-highlight-numbers-number">1</span>, -<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">)</span>:
            <span class="org-keyword">for</span> k <span class="org-keyword">in</span> <span class="org-builtin">range</span><span class="org-rainbow-delimiters-depth-1">(</span>i+<span class="org-highlight-numbers-number">1</span>, j<span class="org-rainbow-delimiters-depth-1">)</span>:
                <span class="org-keyword">for</span> production <span class="org-keyword">in</span> g.find_compatible_binary_productions<span class="org-rainbow-delimiters-depth-1">(</span>m<span class="org-rainbow-delimiters-depth-2">[</span>i<span class="org-rainbow-delimiters-depth-2">][</span>k<span class="org-rainbow-delimiters-depth-2">]</span>, m<span class="org-rainbow-delimiters-depth-2">[</span>k<span class="org-rainbow-delimiters-depth-2">][</span>j<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>:
                    <span class="org-variable-name">a</span> = production<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>
                    <span class="org-variable-name">b</span> = production<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-1">]</span>
                    <span class="org-variable-name">c</span> = production<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">][</span><span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-1">]</span>
                    <span class="org-variable-name">p</span> = production<span class="org-rainbow-delimiters-depth-1">[</span><span class="org-highlight-numbers-number">2</span><span class="org-rainbow-delimiters-depth-1">]</span>
                    <span class="org-variable-name">prod</span> = p * m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>k<span class="org-rainbow-delimiters-depth-1">][</span>b<span class="org-rainbow-delimiters-depth-1">]</span> * m<span class="org-rainbow-delimiters-depth-1">[</span>k<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>c<span class="org-rainbow-delimiters-depth-1">]</span>
                    <span class="org-keyword">if</span> m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>a<span class="org-rainbow-delimiters-depth-1">]</span> &lt; prod:
                        m<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>a<span class="org-rainbow-delimiters-depth-1">]</span> = prod
                        back<span class="org-rainbow-delimiters-depth-1">[</span>i<span class="org-rainbow-delimiters-depth-1">][</span>j<span class="org-rainbow-delimiters-depth-1">][</span>a<span class="org-rainbow-delimiters-depth-1">]</span> = <span class="org-rainbow-delimiters-depth-1">(</span>k, b, c<span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-1">(</span>build_tree<span class="org-rainbow-delimiters-depth-2">(</span>words, m, back, <span class="org-highlight-numbers-number">0</span>, n-<span class="org-highlight-numbers-number">1</span>, <span class="org-string">"S"</span><span class="org-rainbow-delimiters-depth-2">)</span>, m<span class="org-rainbow-delimiters-depth-2">[</span><span class="org-highlight-numbers-number">0</span><span class="org-rainbow-delimiters-depth-2">][</span>n-<span class="org-highlight-numbers-number">1</span><span class="org-rainbow-delimiters-depth-2">][</span><span class="org-string">"S"</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-variable-name">g</span> = <span class="org-constant">None</span>
<span class="org-keyword">def</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span>:
    <span class="org-keyword">global</span> g
    <span class="org-variable-name">g</span> = PCFG<span class="org-rainbow-delimiters-depth-1">()</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"S"</span>,   <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"NP"</span>, <span class="org-string">"VP"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">80</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"NP"</span>,  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"Det"</span>, <span class="org-string">"N"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">30</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"VP"</span>,  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"V"</span>, <span class="org-string">"NP"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">20</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"V"</span>,   <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"includes"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">05</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"the"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">40</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"Det"</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"a"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">40</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"N"</span>,   <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"meal"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">01</span><span class="org-rainbow-delimiters-depth-1">)</span>
    g.add_production<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"N"</span>,   <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">"flight"</span><span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-highlight-numbers-number">0</span>.<span class="org-highlight-numbers-number">02</span><span class="org-rainbow-delimiters-depth-1">)</span>

    <span class="org-keyword">print</span><span class="org-rainbow-delimiters-depth-1">(</span>cky<span class="org-rainbow-delimiters-depth-2">(</span>g, <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">"the"</span>, <span class="org-string">"flight"</span>, <span class="org-string">"includes"</span>, <span class="org-string">"a"</span>, <span class="org-string">"meal"</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

main<span class="org-rainbow-delimiters-depth-1">()</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">(['S',</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">['NP',</span>
<span class="org-comment-delimiter">#    </span><span class="org-comment">['Det', 'the'],</span>
<span class="org-comment-delimiter">#    </span><span class="org-comment">['N', 'flight']],</span>
<span class="org-comment-delimiter">#   </span><span class="org-comment">['VP',</span>
<span class="org-comment-delimiter">#    </span><span class="org-comment">['V', 'includes'],</span>
<span class="org-comment-delimiter">#    </span><span class="org-comment">['NP', ['Det', 'a'],</span>
<span class="org-comment-delimiter">#    </span><span class="org-comment">['N', 'meal']]]],</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">2.3040000000000003e-08)</span>
</pre>
</div>
<style>
body { 
    max-width: 800px; 
    margin: 0 auto 0 auto;
} 
img { width: 100%; }
</style>
<!-- for svg -->
<style> .figure object { height: 250px; } </style>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Notes</h2>
<div class="outline-text-2" id="text-">
<p>
Dependency grammars lack constituents, construct graph from morphs. Easier to deal with free word order as word order no longer figures into the syntactic structure. Dependency structures also seem to more closely mirror semantic structures, making them more directly useful for coreference resolution, question answering, and information extraction, without the need for head finding.
</p>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.1 Dependency Relations</h3>
<div class="outline-text-3" id="text-">
<p>
A syntactic parse is made recursively with two basic pieces: <b>head</b> and <b>dependent</b>. Dependents directly linked to heads, links are labeled with a <b>grammatical function</b>. Functions can be more or less traditional, Universal Dependencies project has arrived on a set that are cross-linguistically applicable.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.2 Dependency Formalisms</h3>
<div class="outline-text-3" id="text-">
<p>
Dependency structures are graphs \(G = (V,A)\) where \(V\) is a set of vertices and \(A\) is a set of ordered pairs of vertices (arcs). Further requirements, based on the flavor, e.g. structures must be connected, have a designated root, be acyclic or planar.
</p>

<p>
Most common requirement: graph must be a dependency tree, i.e.:
</p>

<ol class="org-ol">
<li>Single designated root with no incoming arcs
</li>
<li>Exactly one incoming arc for all other nodes
</li>
<li>Exactly one path from root to each node
</li>
</ol>

<p>
Projectivity: arc from head to dependent is projective if there is an arc from the head to every word that lies between the head and the dependent. Non-projective structures arise from some constructions, but (1) some algorithms only work on projective trees, and (2) dependency resources translated from treebanks are necessarily projective since CFG's are projective.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.3 Dependency Treebanks</h3>
<div class="outline-text-3" id="text-">
<p>
While some dependency treebanks were made directly, many were translated from constituent-based treebanks. 
</p>

<p>
Translating from constituent to dependency structures: need to identify head-dependent relations, and identify the correct dependency relation for each. Xia and Palmer's algorithm:
</p>

<ol class="org-ol">
<li>Mark the head child of each node in a phrase structure, using the appropriate head rules.
</li>
<li>In the dependency structure, make the head of each non-head child depend on the head of the head-child.
</li>
</ol>

<p>
Shortcomings of translation: morphological information not exploited, no non-projective structures. Outside of English, most dependency treebanks directly developed.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.4 Transition-Based Dependency Finding</h3>
<div class="outline-text-3" id="text-">
<p>
<b>Shift-reduce parsing</b>: scan the sequence left to right, push tokens onto stack, use a reduce operation that introduces a dependency between the top two items on the stack (either way).
</p>

<p>
State of the parser referred to as the <b>configuration</b>, consists of (1) the stack, (2) the input buffer, (3) the set of dependency relations. Need to reach a final configuration through <b>transitions</b> where all words have been accommodated into the set of dependency relations.
</p>

<p>
Three possible transitionsin the <b>arc-standard</b> approach to transition parsing: 
</p>

<ol class="org-ol">
<li>LEFTARC: assert relation between item on top of stack and one directly beneath. Also remove lower word from the stack.
</li>
<li>RIGHTARC: assert relation between the second word on the stack and the word on top. Also remove top word from the stack.
</li>
<li>SHIFT: remove one word from the buffer and push onto stack
</li>
</ol>

<p>
How are these steps chosen at each transition? An oracle tells us.
</p>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Oracle Training</h4>
<div class="outline-text-4" id="text-">
<p>
Oracle trained using supervised machine learning. Training data (i.e., choices of transition given particular configurations) is not available directly in trees, but the decisions can be gained easily by simulating a parse with a training oracle.
</p>

<p>
Feature selection is more dependent on language, genre, etc. Focus is usually on the top levels of the stack, words near the front of the buffer, and dependency relations already associated with any of those elements. Can conduct complicated feature engineering to get good results, but neural nets have made advances and may have made this unnecessary.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Other Transition Systems</h4>
<div class="outline-text-4" id="text-">
<p>
<b>arc-eager</b> transition system modifies the set of operations slightly so that left arcs can be captured sooner. The arc-standard system delays this as a consequence of its design, which can sometimes lead to things going "awry" the longer a left arc is left undrawn. Now there is a rich ecosystem of transition systems that can be chosen from depending on the problem at hand.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-4">
<h4 id="sec-">Beam Search</h4>
<div class="outline-text-4" id="text-">
<p>
Weakness of shift-reduce parsing: decisions are irreversible. Beam search uses a bounded BFS to simultaneously explore many transition sequences. Competing sequences are scored, and only sequences with a score higher than the worst sequence in the beam-width are allowed to stay on the agenda.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.5 Graph-Based Dependency Parsing</h3>
<div class="outline-text-3" id="text-">
<p>
Transition-based approaches can't produce projective relations, and empirically, transition-based methods perform worse as distance between head and dependent increases. Graph-based parsing isn't greedy, so it has the potential to avoid this issue. One popular approach: frame the problem as that of constructing a maximum spanning tree.
</p>

<p>
First attempt at an MST algorithm, assuming we have a fully connected graph with edges and their weights from which we are to choose:
</p>

<ol class="org-ol">
<li>For each node, choose just one incoming edge, the one with the highest weight
</li>
</ol>

<p>
But this doesn't guarantee a spanning tree since it could produce cycles. Fortunately, we can enter a cleanup phase using the Chu-Liu Edmonds algorithm:
</p>

<ol class="org-ol">
<li>Adjust all weights by subtracting the score of the maximum edge entering each vertex from the score of all edges entering that vertex.
</li>
<li>Recursively (1) collapse a cycle by merging cyclic nodes into each other, removing interior edges and keeping exterior edges; (2) find the new MST for this changed graph and note the edge that goes into the collapsed cycle node (this may require recursion); (3) keep the recorded edge back in the original graph, which breaks the cycle since the edge we chose in the previous step now replaces a link in the cycle
</li>
</ol>

<p>
Learning edge weights: traditionally hand-engineered features were used, but RNN models have overtaken them, just as with transition-based parsers.
</p>
</div>
</div>

<div id="outline-container-sec-" class="outline-3">
<h3 id="sec-">13.6 Evaluation</h3>
<div class="outline-text-3" id="text-">
<p>
Exact match is too insensitive a materic. Labeled and unlabeled attachment accuracy (LAS, UAS) and label accuracy score (LS, which looks at node labels regardless of their source) used instead. Can also look at precision and recall for a particular kind of dependency relation.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-" class="outline-2">
<h2 id="sec-">Exercises</h2>
<div class="outline-text-2" id="text-">
<p>
None yet in the draft
</p>
</div>
</div>
</div><div class="col-md-3"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#sec-">Exercises</a>
<ul class="nav">
<li><a href="#sec-">2.1</a></li>
<li><a href="#sec-">2.8</a></li>
<li><a href="#sec-">2.10</a></li>
<li><a href="#sec-">2.11</a></li>
</ul>
</li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">3.4 FSTs</a></li>
<li><a href="#sec-">3.5 FSTs for Morphological Parsing</a></li>
<li><a href="#sec-">3.6 Orthographic Rules</a></li>
<li><a href="#sec-">3.7 Combining FST Lexicon and Rules</a></li>
<li><a href="#sec-">3.8 Lexicon-free FSTs: The Porter Stemmer</a></li>
<li><a href="#sec-">3.9 Word and Sentence Tokenization</a></li>
<li><a href="#sec-">3.10 Spelling correction</a></li>
<li><a href="#sec-">3.11 Minimum Edit Distance</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a>
<ul class="nav">
<li><a href="#sec-">3.1</a></li>
<li><a href="#sec-">3.2</a></li>
<li><a href="#sec-">3.3</a></li>
<li><a href="#sec-">3.5</a></li>
<li><a href="#sec-">3.9</a></li>
<li><a href="#sec-">3.10</a></li>
<li><a href="#sec-">3.11</a></li>
</ul>
</li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">4.1 N-grams</a></li>
<li><a href="#sec-">4.2 Evaluating language models</a></li>
<li><a href="#sec-">4.3 Generalization and zeros</a></li>
<li><a href="#sec-">4.4 Smoothing</a></li>
<li><a href="#sec-">4.5 Kneser-Ney smoothing</a></li>
<li><a href="#sec-">The web and stupid backoff</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a>
<ul class="nav">
<li><a href="#sec-">4.1</a></li>
<li><a href="#sec-">4.2</a></li>
<li><a href="#sec-">4.3</a></li>
<li><a href="#sec-">4.4</a></li>
<li><a href="#sec-">4.5</a></li>
<li><a href="#sec-">4.6</a></li>
<li><a href="#sec-">4.7</a></li>
</ul>
</li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">9.1 Markov Chains</a></li>
<li><a href="#sec-">9.2 Hidden Markov Models</a></li>
<li><a href="#sec-">9.3 Computing likelihood, forward algorithm</a></li>
<li><a href="#sec-">9.4 Decoding, Viterbi algorithm</a></li>
<li><a href="#sec-">9.5 Training, forward-backward algorithm</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a></li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">10.2 Context Free Grammars</a></li>
<li><a href="#sec-">10.5 Grammar Equivalence and Normal Form</a></li>
<li><a href="#sec-">10.6 Lexicalized Grammars</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a>
<ul class="nav">
<li><a href="#sec-">10.3</a></li>
<li><a href="#sec-">10.4</a></li>
<li><a href="#sec-">10.5</a></li>
<li><a href="#sec-">10.6</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a></li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">12.1 Probabilistic CFG's</a></li>
<li><a href="#sec-">12.2 Probabilistic CKY Parsing</a></li>
<li><a href="#sec-">12.3 Learning Production Probabilities</a></li>
<li><a href="#sec-">12.4 PCFG problems</a></li>
<li><a href="#sec-">12.5 Splitting Non-Terminals to Address Independence Assumptions</a></li>
<li><a href="#sec-">12.6 Probabilistic Lexicalized CFGs</a></li>
<li><a href="#sec-">12.7 Probabilistic CCG Parsing</a></li>
<li><a href="#sec-">12.8 Evaluating Parsers</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a>
<ul class="nav">
<li><a href="#sec-">12.1 Probabilistic CKY</a></li>
</ul>
</li>
<li><a href="#sec-">Notes</a>
<ul class="nav">
<li><a href="#sec-">13.1 Dependency Relations</a></li>
<li><a href="#sec-">13.2 Dependency Formalisms</a></li>
<li><a href="#sec-">13.3 Dependency Treebanks</a></li>
<li><a href="#sec-">13.4 Transition-Based Dependency Finding</a></li>
<li><a href="#sec-">13.5 Graph-Based Dependency Parsing</a></li>
<li><a href="#sec-">13.6 Evaluation</a></li>
</ul>
</li>
<li><a href="#sec-">Exercises</a></li>
</ul>
</div>
</nav>
</div></div></div>
<footer id="postamble" class="">
<div class="container"><div class="row"><div class="col-md-9"><div id="disqus_thread"></div></div></div></div>
</footer>
</body>
</html>
